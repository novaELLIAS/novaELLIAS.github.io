{"meta":{"title":"Next Dream...","subtitle":null,"description":null,"author":"ELLIAS","url":"https://novaellias.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-10T09:02:51.293Z","updated":"2019-06-05T11:45:47.777Z","comments":true,"path":"404.html","permalink":"https://novaellias.github.io/404.html","excerpt":"","text":"404 Not Found This object has escaped into fantasy Please contact the Administrator"},{"title":"","date":"2019-06-01T11:31:37.462Z","updated":"2019-06-01T11:31:37.462Z","comments":true,"path":"googleee23d67b90dfc2e5.html","permalink":"https://novaellias.github.io/googleee23d67b90dfc2e5.html","excerpt":"","text":"google-site-verification: googleee23d67b90dfc2e5.html"},{"title":"About","date":"2020-02-13T14:47:14.343Z","updated":"2020-02-13T14:47:14.343Z","comments":true,"path":"about/index.html","permalink":"https://novaellias.github.io/about/index.html","excerpt":"","text":"InformationID: Kishin ELLIAS school: DLYMGZ AFO: @NOIp2018 Contact MeLuogu: 65678 Malody: Ellias_K WeChat :QQ: 3218673140Email: eternalkiri@outlook.com"},{"title":"categories","date":"2019-06-05T11:25:35.240Z","updated":"2019-06-05T11:25:35.240Z","comments":true,"path":"categories/index.html","permalink":"https://novaellias.github.io/categories/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-02-17T03:40:30.560Z","updated":"2019-06-15T11:22:42.721Z","comments":true,"path":"friends/index.html","permalink":"https://novaellias.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-17T04:48:04.260Z","updated":"2020-02-17T04:48:04.260Z","comments":true,"path":"hiddenlist/index.html","permalink":"https://novaellias.github.io/hiddenlist/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-05T11:26:48.096Z","updated":"2019-06-05T11:26:48.096Z","comments":true,"path":"tags/index.html","permalink":"https://novaellias.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-17T04:44:21.197Z","updated":"2020-02-17T04:44:21.197Z","comments":true,"path":"game/2048/index.html","permalink":"https://novaellias.github.io/game/2048/index.html","excerpt":"","text":"2048 2048 Please operate with arrow keys. New Game score:0 GAME OVER document.onkeydown = function (e) { var currKey = 0, evt = e || window.event; currKey = evt.keyCode || evt.which || evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2020-02-17T08:15:02.160Z","updated":"2020-02-17T08:15:02.160Z","comments":true,"path":"game/element/index.html","permalink":"https://novaellias.github.io/game/element/index.html","excerpt":"","text":"Elements html, body { height: 100%; } body { background-color: #000000; margin: 0; font-family: Helvetica, sans-serif; ; overflow: hidden; } a { color: #ffffff; } #info { position: absolute; width: 100%; color: #ffffff; padding: 5px; font-family: Monospace; font-size: 13px; font-weight: bold; text-align: center; z-index: 1; } #menu { position: absolute; bottom: 20px; width: 100%; text-align: center; font-family: verdana, Tahoma, Arial, Hei, \"Microsoft Yahei\", SimHei; } .element { width: 120px; height: 160px; box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.5); border: 1px solid rgba(127, 255, 255, 0.25); text-align: center; cursor: default; } .element:hover { box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.75); border: 1px solid rgba(127, 255, 255, 0.75); } .element .number { position: absolute; top: 20px; right: 20px; font-size: 12px; color: rgba(127, 255, 255, 0.75); } .element .symbol { position: absolute; top: 40px; left: 0px; right: 0px; font-size: 60px; font-weight: bold; color: rgba(255, 255, 255, 0.75); text-shadow: 0 0 10px rgba(0, 255, 255, 0.95); } .element .details { position: absolute; bottom: 15px; left: 0px; right: 0px; font-size: 12px; color: rgba(127, 255, 255, 0.75); } button { color: rgba(127, 255, 255, 0.75); background: transparent; outline: 1px solid rgba(127, 255, 255, 0.75); border: 0px; padding: 5px 10px; cursor: pointer; } button:hover { background-color: rgba(0, 255, 255, 0.5); } button:active { color: #000000; background-color: rgba(0, 255, 255, 0.75); } TABLE SPHERE HELIX GRID var table = [ \"H\", \"Hydrogen\", \"1.00794\", 1, 1, \"He\", \"Helium\", \"4.002602\", 18, 1, \"Li\", \"Lithium\", \"#6.941\", 1, 2, \"Be\", \"Beryllium\", \"9.012182\", 2, 2, \"B\", \"Boron\", \"#10.811\", 13, 2, \"C\", \"Carbon\", \"#12.0107\", 14, 2, \"N\", \"Nitrogen\", \"#14.0067\", 15, 2, \"O\", \"Oxygen\", \"#15.9994\", 16, 2, \"F\", \"Fluorine\", \"18.9984032\", 17, 2, \"Ne\", \"Neon\", \"#20.1797\", 18, 2, \"Na\", \"Sodium\", \"22.98976...\", 1, 3, \"Mg\", \"Magnesium\", \"#24.305\", 2, 3, \"Al\", \"Aluminium\", \"26.9815386\", 13, 3, \"Si\", \"Silicon\", \"#28.0855\", 14, 3, \"P\", \"Phosphorus\", \"30.973762\", 15, 3, \"S\", \"Sulfur\", \"#32.065\", 16, 3, \"Cl\", \"Chlorine\", \"#35.453\", 17, 3, \"Ar\", \"Argon\", \"#39.948\", 18, 3, \"K\", \"Potassium\", \"#39.948\", 1, 4, \"Ca\", \"Calcium\", \"#40.078\", 2, 4, \"Sc\", \"Scandium\", \"44.955912\", 3, 4, \"Ti\", \"Titanium\", \"#47.867\", 4, 4, \"V\", \"Vanadium\", \"#50.9415\", 5, 4, \"Cr\", \"Chromium\", \"#51.9961\", 6, 4, \"Mn\", \"Manganese\", \"54.938045\", 7, 4, \"Fe\", \"Iron\", \"#55.845\", 8, 4, \"Co\", \"Cobalt\", \"58.933195\", 9, 4, \"Ni\", \"Nickel\", \"#58.6934\", 10, 4, \"Cu\", \"Copper\", \"#63.546\", 11, 4, \"Zn\", \"Zinc\", \"#65.38\", 12, 4, \"Ga\", \"Gallium\", \"#69.723\", 13, 4, \"Ge\", \"Germanium\", \"#72.63\", 14, 4, \"As\", \"Arsenic\", \"#74.9216\", 15, 4, \"Se\", \"Selenium\", \"#78.96\", 16, 4, \"Br\", \"Bromine\", \"#79.904\", 17, 4, \"Kr\", \"Krypton\", \"#83.798\", 18, 4, \"Rb\", \"Rubidium\", \"#85.4678\", 1, 5, \"Sr\", \"Strontium\", \"#87.62\", 2, 5, \"Y\", \"Yttrium\", \"88.90585\", 3, 5, \"Zr\", \"Zirconium\", \"#91.224\", 4, 5, \"Nb\", \"Niobium\", \"92.90628\", 5, 5, \"Mo\", \"Molybdenum\", \"#95.96\", 6, 5, \"Tc\", \"Technetium\", \"(98)\", 7, 5, \"Ru\", \"Ruthenium\", \"#101.07\", 8, 5, \"Rh\", \"Rhodium\", \"#102.9055\", 9, 5, \"Pd\", \"Palladium\", \"#106.42\", 10, 5, \"Ag\", \"Silver\", \"#107.8682\", 11, 5, \"Cd\", \"Cadmium\", \"#112.411\", 12, 5, \"In\", \"Indium\", \"#114.818\", 13, 5, \"Sn\", \"Tin\", \"#118.71\", 14, 5, \"Sb\", \"Antimony\", \"#121.76\", 15, 5, \"Te\", \"Tellurium\", \"127.6\", 16, 5, \"I\", \"Iodine\", \"126.90447\", 17, 5, \"Xe\", \"Xenon\", \"#131.293\", 18, 5, \"Cs\", \"Caesium\", \"#132.9054\", 1, 6, \"Ba\", \"Barium\", \"#132.9054\", 2, 6, \"La\", \"Lanthanum\", \"138.90547\", 4, 9, \"Ce\", \"Cerium\", \"#140.116\", 5, 9, \"Pr\", \"Praseodymium\", \"140.90765\", 6, 9, \"Nd\", \"Neodymium\", \"#144.242\", 7, 9, \"Pm\", \"Promethium\", \"(145)\", 8, 9, \"Sm\", \"Samarium\", \"#150.36\", 9, 9, \"Eu\", \"Europium\", \"#151.964\", 10, 9, \"Gd\", \"Gadolinium\", \"#157.25\", 11, 9, \"Tb\", \"Terbium\", \"158.92535\", 12, 9, \"Dy\", \"Dysprosium\", \"162.5\", 13, 9, \"Ho\", \"Holmium\", \"164.93032\", 14, 9, \"Er\", \"Erbium\", \"#167.259\", 15, 9, \"Tm\", \"Thulium\", \"168.93421\", 16, 9, \"Yb\", \"Ytterbium\", \"#173.054\", 17, 9, \"Lu\", \"Lutetium\", \"#174.9668\", 18, 9, \"Hf\", \"Hafnium\", \"#178.49\", 4, 6, \"Ta\", \"Tantalum\", \"180.94788\", 5, 6, \"W\", \"Tungsten\", \"#183.84\", 6, 6, \"Re\", \"Rhenium\", \"#186.207\", 7, 6, \"Os\", \"Osmium\", \"#190.23\", 8, 6, \"Ir\", \"Iridium\", \"#192.217\", 9, 6, \"Pt\", \"Platinum\", \"#195.084\", 10, 6, \"Au\", \"Gold\", \"196.966569\", 11, 6, \"Hg\", \"Mercury\", \"#200.59\", 12, 6, \"Tl\", \"Thallium\", \"#204.3833\", 13, 6, \"Pb\", \"Lead\", \"207.2\", 14, 6, \"Bi\", \"Bismuth\", \"#208.9804\", 15, 6, \"Po\", \"Polonium\", \"(209)\", 16, 6, \"At\", \"Astatine\", \"(210)\", 17, 6, \"Rn\", \"Radon\", \"(222)\", 18, 6, \"Fr\", \"Francium\", \"(223)\", 1, 7, \"Ra\", \"Radium\", \"(226)\", 2, 7, \"Ac\", \"Actinium\", \"(227)\", 4, 10, \"Th\", \"Thorium\", \"232.03806\", 5, 10, \"Pa\", \"Protactinium\", \"#231.0588\", 6, 10, \"U\", \"Uranium\", \"238.02891\", 7, 10, \"Np\", \"Neptunium\", \"(237)\", 8, 10, \"Pu\", \"Plutonium\", \"(244)\", 9, 10, \"Am\", \"Americium\", \"(243)\", 10, 10, \"Cm\", \"Curium\", \"(247)\", 11, 10, \"Bk\", \"Berkelium\", \"(247)\", 12, 10, \"Cf\", \"Californium\", \"(251)\", 13, 10, \"Es\", \"Einstenium\", \"(252)\", 14, 10, \"Fm\", \"Fermium\", \"(257)\", 15, 10, \"Md\", \"Mendelevium\", \"(258)\", 16, 10, \"No\", \"Nobelium\", \"(259)\", 17, 10, \"Lr\", \"Lawrencium\", \"(262)\", 18, 10, \"Rf\", \"Rutherfordium\", \"(267)\", 4, 7, \"Db\", \"Dubnium\", \"(268)\", 5, 7, \"Sg\", \"Seaborgium\", \"(271)\", 6, 7, \"Bh\", \"Bohrium\", \"(272)\", 7, 7, \"Hs\", \"Hassium\", \"(270)\", 8, 7, \"Mt\", \"Meitnerium\", \"(276)\", 9, 7, \"Ds\", \"Darmstadium\", \"(281)\", 10, 7, \"Rg\", \"Roentgenium\", \"(280)\", 11, 7, \"Cn\", \"Copernicium\", \"(285)\", 12, 7, \"Uut\", \"Unutrium\", \"(284)\", 13, 7, \"Fl\", \"Flerovium\", \"(289)\", 14, 7, \"Uup\", \"Ununpentium\", \"(288)\", 15, 7, \"Lv\", \"Livermorium\", \"(293)\", 16, 7, \"Uus\", \"Ununseptium\", \"(294)\", 17, 7, \"Uuo\", \"Ununoctium\", \"(294)\", 18, 7 ]; var camera, scene, renderer; var controls; var objects = []; var targets = { table: [], sphere: [], helix: [], grid: [] }; init(); animate(); function init() { camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000); camera.position.z = 3000; scene = new THREE.Scene(); // table for (var i = 0; i < table.length; i += 5) { var element = document.createElement('div'); element.className = 'element'; element.style.backgroundColor = 'rgba(0,127,127,' + (Math.random() * 0.5 + 0.25) + ')'; var number = document.createElement('div'); number.className = 'number'; number.textContent = (i / 5) + 1; element.appendChild(number); var symbol = document.createElement('div'); symbol.className = 'symbol'; symbol.textContent = table[i]; element.appendChild(symbol); var details = document.createElement('div'); details.className = 'details'; details.innerHTML = table[i + 1] + '' + table[i + 2]; element.appendChild(details); var object = new THREE.CSS3DObject(element); object.position.x = Math.random() * 4000 - 2000; object.position.y = Math.random() * 4000 - 2000; object.position.z = Math.random() * 4000 - 2000; scene.add(object); objects.push(object); // var object = new THREE.Object3D(); object.position.x = (table[i + 3] * 140) - 1330; object.position.y = -(table[i + 4] * 180) + 990; targets.table.push(object); } // sphere var vector = new THREE.Vector3(); for (var i = 0, l = objects.length; i < l; i++) { var phi = Math.acos(-1 + (2 * i) / l); var theta = Math.sqrt(l * Math.PI) * phi; var object = new THREE.Object3D(); object.position.x = 800 * Math.cos(theta) * Math.sin(phi); object.position.y = 800 * Math.sin(theta) * Math.sin(phi); object.position.z = 800 * Math.cos(phi); vector.copy(object.position).multiplyScalar(2); object.lookAt(vector); targets.sphere.push(object); } // helix var vector = new THREE.Vector3(); for (var i = 0, l = objects.length; i < l; i++) { var phi = i * 0.175 + Math.PI; var object = new THREE.Object3D(); object.position.x = 900 * Math.sin(phi); object.position.y = -(i * 8) + 450; object.position.z = 900 * Math.cos(phi); vector.x = object.position.x * 2; vector.y = object.position.y; vector.z = object.position.z * 2; object.lookAt(vector); targets.helix.push(object); } // grid for (var i = 0; i < objects.length; i++) { var object = new THREE.Object3D(); object.position.x = ((i % 5) * 400) - 800; object.position.y = (-(Math.floor(i / 5) % 5) * 400) + 800; object.position.z = (Math.floor(i / 25)) * 1000 - 2000; targets.grid.push(object); } // renderer = new THREE.CSS3DRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); renderer.domElement.style.position = 'absolute'; document.getElementById('container').appendChild(renderer.domElement); // controls = new THREE.TrackballControls(camera, renderer.domElement); controls.rotateSpeed = 0.5; controls.minDistance = 500; controls.maxDistance = 6000; controls.addEventListener('change', render); var button = document.getElementById('table'); button.addEventListener('click', function (event) { transform(targets.table, 2000); }, false); var button = document.getElementById('sphere'); button.addEventListener('click', function (event) { transform(targets.sphere, 2000); }, false); var button = document.getElementById('helix'); button.addEventListener('click', function (event) { transform(targets.helix, 2000); }, false); var button = document.getElementById('grid'); button.addEventListener('click', function (event) { transform(targets.grid, 2000); }, false); transform(targets.table, 5000); // window.addEventListener('resize', onWindowResize, false); } function transform(targets, duration) { TWEEN.removeAll(); for (var i = 0; i < objects.length; i++) { var object = objects[i]; var target = targets[i]; new TWEEN.Tween(object.position) .to({ x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration) .easing(TWEEN.Easing.Exponential.InOut) .start(); new TWEEN.Tween(object.rotation) .to({ x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration) .easing(TWEEN.Easing.Exponential.InOut) .start(); } new TWEEN.Tween(this) .to({}, duration * 2) .onUpdate(render) .start(); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); render(); } function animate() { requestAnimationFrame(animate); TWEEN.update(); controls.update(); } function render() { renderer.render(scene, camera); } document.onkeydown = function (e) { var currKey = 0, evt = e || window.event; currKey = evt.keyCode || evt.which || evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"}],"posts":[{"title":"扫盲向 利用OBS虚拟摄像头在网课上摸鱼","slug":"obs_internet_class_fishing","date":"2020-03-01T02:08:23.000Z","updated":"2020-03-01T14:41:40.228Z","comments":true,"path":"obs_internet_class_fishing/","link":"","permalink":"https://novaellias.github.io/obs_internet_class_fishing/","excerpt":"Windows OBS OBS-VirtualCam Facerig","text":"Windows OBS OBS-VirtualCam Facerig INTRODUCTION 「摸鱼之心，人皆有之，咸者能毋丧耳。」 – Hanyuu ELLIAS REQUIREMENT Open Broadcaster Software OBS-VirtualCam Install and run. USEINPUT在”来源”中点击加号添加. 作为视频或图像录一段学习时候的视频或选择一张贴纸. 选择VLC视频源或图像. 点击加号添加文件或路径. 作为视频源添加视频捕获装置 作为示例,这里选择了Facerig的虚拟摄像头. 我很可爱,请给我钱! 这个模型来自创意工坊,作者为toribako145. 确保其被激活.分辨率选项视情况而定. 将画面充满屏幕. 用上下箭头调整前后位置.确保其出于可视状态. OUTPUT工具-&gt;虚拟摄像头. 选择目标摄像头(默认即可),水平翻转及保持长宽比例视情况使用. 缓冲帧视性能调整. 启动即可. IN CLASS选择刚才设置的目标摄像头即可. OTHERS 低配置设备可在设置-&gt;视频中调整分辨率来缓解卡顿. 不使用物理摄像头时将其遮住是个好习惯. 使用Facerig时请留意各方面的版权限制. 摸鱼有风险,使用需谨慎. 请各位”务必”以学业为重! 博客内容遵循 Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) 协议. 本文永久链接: https://novaellias.github.io/obs_internet_class_fishing","categories":[{"name":"Trick","slug":"Trick","permalink":"https://novaellias.github.io/categories/Trick/"}],"tags":[{"name":"OBS","slug":"OBS","permalink":"https://novaellias.github.io/tags/OBS/"}]},{"title":"buzzer scale define","slug":"buzzer-define","date":"2019-07-07T02:29:42.000Z","updated":"2019-07-07T02:29:32.616Z","comments":true,"path":"buzzer-define/","link":"","permalink":"https://novaellias.github.io/buzzer-define/","excerpt":"buzzer scale define","text":"buzzer scale define 123456789101112131415161718192021222324252627282930313233343536#define ddo 262#define dre 294#define dmi 330#define dfa 349#define dso 392#define dla 440#define dsi 494#define do 523#define re 578#define mi 659#define fa 698#define so 784#define la 880#define si 988#define udo 1046#define ure 1175#define umi 1318#define ufa 1480#define uso 1568#define ula 1760#define usi 1976#define sddo 277#define sdre 311#define sdfa 370#define sdso 415#define sdla 466#define sdo 554#define sre 622#define sfa 740#define sso 831#define sla 932#define sudo 1046#define sure 1245#define sufa 1480#define suso 1661#define sula 1865","categories":[{"name":"IT","slug":"IT","permalink":"https://novaellias.github.io/categories/IT/"}],"tags":[{"name":"Template","slug":"Template","permalink":"https://novaellias.github.io/tags/Template/"},{"name":"buzzer","slug":"buzzer","permalink":"https://novaellias.github.io/tags/buzzer/"}]},{"title":"ELLIAS的OI之路","slug":"oi_history","date":"2019-02-02T05:57:07.000Z","updated":"2019-06-17T13:55:46.419Z","comments":true,"path":"oi_history/","link":"","permalink":"https://novaellias.github.io/oi_history/","excerpt":"从录取到退役 ELLIAS的OI之路","text":"从录取到退役 ELLIAS的OI之路 2017.7.24 YM录取 2017.12.29 YM1.12新年联欢会OIer合影 2018.1.19 先修调人 YM1.12教室 2018.4.7 窗外风景 非正式参加LN胜选 2018.7.16 YMOI校内集训 2018.7.25 24中集训 2019 NOIp2018省一退役 次の旅を楽しみにしています!","categories":[{"name":"memory","slug":"memory","permalink":"https://novaellias.github.io/categories/memory/"}],"tags":[]},{"title":"倍增 洛谷P1967 货车运输","slug":"luogu-P1967-noip2018-day-1","date":"2018-11-09T13:20:49.000Z","updated":"2019-06-10T11:32:06.832Z","comments":true,"path":"luogu-P1967-noip2018-day-1/","link":"","permalink":"https://novaellias.github.io/luogu-P1967-noip2018-day-1/","excerpt":"NOIp2018 day-1RP倍增祈愿luogu P1967","text":"NOIp2018 day-1RP倍增祈愿luogu P1967 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201// luogu-judger-enable-o2#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\")#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;#include &lt;algorithm&gt;using std::sort;#define Re register#define maxn 100001#define maxe 50001#define swap(x,y) ((x)^=(y)^=(x)^=(y))const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = 0; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') c = gc(), m = true; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;inline const int&amp; min (const int&amp; a, const int&amp; b) &#123;return a&lt;b? a:b;&#125;struct node &#123; int fr, to, va;&#125; edge[maxe];inline bool cmp (node a, node b)&#123; return a.va &gt; b.va;&#125;int head[maxn], nxt[maxn], too[maxn], wei[maxn], ecnt;inline void addedge_d (Re int fr, Re int to, Re int va)&#123; nxt[++ ecnt]=head[fr], head[fr]=ecnt, too[ecnt]=to, wei[ecnt]=va; nxt[++ ecnt]=head[to], head[to]=ecnt, too[ecnt]=fr, wei[ecnt]=va;&#125;int fa[maxn];inline int find (register int x)&#123; while (x ^ fa[x]) x = fa[x] = fa[fa[x]]; return x;&#125;inline void Kruskal (Re int n, Re int m)&#123; register int i, j, fr, to, va, ffr, fto; for (i=1; i&lt;=m; ++i) &#123; fr=edge[i].fr, to=edge[i].to, ffr=find(fr), fto=find(to); if (ffr ^ fto) addedge_d (fr, to, edge[i].va), fa[ffr]=fto; &#125;&#125;int fl[maxn];int ex[maxn][18], ew[maxn][18];static void build_tree (Re int x, Re int dep)&#123; register int i, j, to, va; if (!fl[x]) &#123; fl[x] = dep; for (i=head[x]; i; i=nxt[i]) &#123; to=too[i], va=wei[i]; if (!fl[to]) &#123; ex[to][0] = x, ew[to][0] = va; build_tree (to, dep + 1); &#125; &#125; &#125;&#125;inline void build_forest (Re int n)&#123; register int i, j, fr, to, va; for (i=1; i&lt;=n; ++i) if (!fl[i]) &#123; ew[i][0] = 0x3f3f3f3f, ex[i][0] = i; build_tree (i, 1); &#125;&#125;inline void lca_init (Re int n)&#123; register int i, j; for (i=1; i&lt;=17; ++i) &#123; for (j=1; j&lt;=n; ++j) &#123; ex[j][i] = ex[ex[j][i-1]][i-1]; ew[j][i] = min (ew[ex[j][i-1]][i-1], ew[j][i-1]); &#125; &#125;&#125;inline int get_lca (Re int fr, Re int to)&#123; if (find(fr) ^ find(to)) return -1; register int ret=0x3f3f3f3f, i, j; if (fl[fr] &gt; fl[to]) swap (fr, to); for (i=17; i&gt;=0; --i) if (fl[ex[to][i]] &gt;= fl[fr]) ret=min (ret, ew[to][i]), to=ex[to][i]; if (fr == to) return ret; for (i=17; i&gt;=0; --i) &#123; if (ex[fr][i] ^ ex[to][i]) &#123; ret = min (ret, min (ew[to][i], ew[fr][i])); to=ex[to][i], fr=ex[fr][i]; &#125; &#125; ret=min(ret,min(ew[fr][0], ew[to][0])); return ret;&#125;signed main ()&#123; register int i, j, fr, to, va; register int n=read(), m=read(); for (i=1; i&lt;=n; ++i) fa[i] = i; for (i=1; i&lt;=m; ++i) &#123; fr=read(), to=read(), va=read(); edge[i] = &#123;fr, to, va&#125;; &#125; sort (edge+1, edge+m+1, cmp); Kruskal (n, m); build_forest (n); lca_init (n); register int _ = read (); while (_ --) writelen (get_lca(read(), read())); return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"https://novaellias.github.io/tags/Template/"},{"name":"倍增","slug":"倍增","permalink":"https://novaellias.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"生成树","slug":"生成树","permalink":"https://novaellias.github.io/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"https://novaellias.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"OPTIMIZATION","slug":"OPTIMIZE","date":"2018-11-07T11:17:42.000Z","updated":"2019-06-10T11:32:32.244Z","comments":true,"path":"OPTIMIZE/","link":"","permalink":"https://novaellias.github.io/OPTIMIZE/","excerpt":"编译选项 快读 快写 内嵌asm","text":"编译选项 快读 快写 内嵌asm LuoguBlog Fast Read &amp; WriteELLIAS_Old123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class fastio &#123; private: inline char gc() &#123; static char buf[1&lt;&lt;14],*p1=buf,*p2=buf; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;14,stdin),p1==p2)?EOF:*p1++; &#125; public: inline void getint (int &amp;to) &#123; register int x = 0; register char c = gc(); register bool m = 0; while (c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9') &amp;&amp; c != '-') c = gc(); if (c == '-') c = gc(), m = 1; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0', c = gc(); if (m) return -x; else return x; &#125; inline void getuint (int &amp;to) &#123; int x = 0; char c = gc(); while (!isdigit(c)) c = gc(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0', c = gc(); to = x; &#125; inline void getdou (double &amp;to) &#123; double x=0; char ch = getchar (); bool m = 0; while (!isdigit(ch) &amp;&amp; ch != '-') ch = gc (); if (ch == '-') ch = gc(), m = 1; while (isdigit(ch)) x = x * 10 + (ch-48), ch = gc (); if (ch == '.') &#123; double s = 0.1; ch = gc (); while (isdigit(ch)) x = x + (ch-48)*s,s/=10,ch = gc (); &#125; if (m) to = -x; else to = x; &#125; inline void getudou (double &amp;to) &#123; double x=0; char ch = gc (); while (!isdigit(ch)) ch = gc (); while (isdigit(ch)) x = x * 10 + (ch-48), ch = gc (); if (ch == '.') &#123; double s = 0.1; ch = gc (); while (isdigit(ch)) x = x + (ch-48)*s,s/=10,ch = gc (); &#125; to = x; &#125; inline void write (int x) &#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48); &#125;&#125; io; SJB1234567891011121314151617181920212223242526272829303132333435namespace fastIO &#123; const int str = 1&lt;&lt;20; const char* kiana = \"\\n\"; struct Reader &#123; char buf[str], *s, *t; bool EOF_FLG; Reader():s(buf), t(buf), EOF_FLG(false) &#123;&#125;; inline char gt() &#123;return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);&#125; template &lt;typename T&gt; Reader&amp;operator &gt;&gt; (T&amp;x) &#123; if (EOF_FLG)return *this; register char c=0,d; while (c != EOF &amp;&amp; (!isdigit(c)))d=c,c=gt(); if(c == EOF) &#123;EOF_FLG=true; return *this;&#125; else x = 0; while(isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + c - '0', c = gt(); if (d == '-') x =- x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123;fwrite(buf,1,s-buf,stdout);&#125; inline void pt(char c) &#123;(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);&#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x) return pt('0'),*this; if(x&lt;0) pt('-'), x = -x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123;while(*s)pt(*s++);return *this;&#125; &#125; cout;&#125; ELLIAS_New1234567891011121314151617181920const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = 0; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') c = gc(), m = true; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125; SWITCHOLD (2017)123456789#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\") OLD(2018.3)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma GCC optimize (2)#pragma G++ optimize (2)#pragma GCC optimize (3)#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\")#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-fwhole-program\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-fstrict-overflow\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-skip-blocks\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"-funsafe-loop-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\") NOIp20181234567891011121314151617181920212223242526272829303132333435363738394041#pragma GCC optimize (2)#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\") 内嵌asm优化a * b % mo12345inline long long mul_mod (register long long a,register long long b,register long long mo) &#123; register long long ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\" : \"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo)); return ret;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"https://novaellias.github.io/tags/Template/"}]},{"title":"GSS1 - Can you answer these queries I","slug":"GSS1","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:31:26.799Z","comments":true,"path":"GSS1/","link":"","permalink":"https://novaellias.github.io/GSS1/","excerpt":"GSS1 - Can you answer these queries I","text":"GSS1 - Can you answer these queries I Luogu SP1043Vjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define rint register intint n, m, x, y, in;struct node &#123; int sum, lmax, rmax, dat;&#125; tr[200001];namespace FastIO &#123; const int str=1&lt;&lt;20; const char* endl=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;(c&lt;'0'||c&gt;'9'))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;inline const int&amp; max(const int&amp; x,const int&amp; y) &#123; return x&gt;y?x:y;&#125;inline void update (int rt) &#123; tr[rt].sum =tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum; tr[rt].lmax= max (tr[rt&lt;&lt;1].lmax, tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].lmax); tr[rt].rmax= max (tr[rt&lt;&lt;1|1].rmax, tr[rt&lt;&lt;1|1].sum + tr[rt&lt;&lt;1].rmax); tr[rt].dat = max (max(tr[rt&lt;&lt;1].dat, tr[rt&lt;&lt;1|1].dat), tr[rt&lt;&lt;1].rmax + tr[rt&lt;&lt;1|1].lmax);&#125;inline void build (int rt,int l,int r) &#123; if(l==r) &#123; FastIO::cin&gt;&gt;in; tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = in; return; &#125; int mid = (l+r)&gt;&gt;1; build (lson); build (rson); update (rt);&#125;inline node query (int rt, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; int mid = (l+r)&gt;&gt;1; if (ql &gt; mid) return query (rson, ql, qr); if (qr &lt;= mid) return query (lson, ql, qr); else &#123; node ans,a,b; a = query (lson,ql,qr); b = query (rson,ql,qr); ans.sum = a.sum + b.sum; ans.dat = max (a.dat, a.rmax + b.lmax), ans.dat = max (ans.dat, b.dat); ans.lmax= max (a.lmax, a.sum + b.lmax); ans.rmax= max (b.rmax, b.sum + a.rmax); return ans; &#125;&#125;using namespace FastIO;int main() &#123; //freopen (\"nico.in\",\"r\",stdin); FastIO::cin&gt;&gt;n; build (1, 1, n); FastIO::cin&gt;&gt;m; while (m --) &#123; FastIO::cin&gt;&gt;x&gt;&gt;y; FastIO::cout&lt;&lt;query(1, 1, n, x, y).dat&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"SP2713 GSS4 - Can you answer these queries IV","slug":"GSS4","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:31:32.924Z","comments":true,"path":"GSS4/","link":"","permalink":"https://novaellias.github.io/GSS4/","excerpt":"GSS4 - Can you answer these queries IV","text":"GSS4 - Can you answer these queries IV LuoguVjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#define root 1,1,n#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define swap(x,y) y^=x^=y^=x#define maxn 100001 #define dmax 400001#define rint register int#define ll long longnamespace fastIO &#123; const int str=1&lt;&lt;20; const char* endll=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; #define gt() getchar() template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;!isdigit(c))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; #define pt(c) putchar(c) template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;using namespace fastIO;struct TreeNode &#123; int l, r; long long sum, mxx;&#125; dat[dmax];long long in;inline const long long&amp; max (const long long&amp; x,const long long&amp; y) &#123;return x&gt;y? x:y;&#125;inline void update (int rt)&#123; dat[rt].sum = dat[rt&lt;&lt;1].sum + dat[rt&lt;&lt;1|1].sum; dat[rt].mxx = max (dat[rt&lt;&lt;1].mxx, dat[rt&lt;&lt;1|1].mxx);&#125;inline void build (int rt, int l, int r)&#123; dat[rt].l = l, dat[rt].r = r; if (l == r) &#123; fastIO::cin &gt;&gt; in; dat[rt].sum = dat[rt].mxx = in; return; &#125; register int mid = (l + r) &gt;&gt; 1; build (lson); build (rson); update (rt);&#125;inline long long query (int rt, int l, int r)&#123; register int L = dat[rt].l, R = dat[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return dat[rt].sum; register int mid = (L + R) &gt;&gt; 1; register long long ret = 0ll; if (l &lt;=mid) ret = query (rt&lt;&lt;1, l, r); if (mid &lt; r) ret += query (rt&lt;&lt;1|1,l,r); return ret;&#125;inline void change (int rt, int l, int r)&#123; register int L = dat[rt].l, R = dat[rt].r; if (L == R) &#123; //cout&lt;&lt;dat[rt].sum&lt;&lt;\" -&gt; \"; dat[rt].sum = sqrt (dat[rt].sum), dat[rt].mxx = sqrt (dat[rt].mxx); //cout&lt;&lt;dat[rt].sum&lt;&lt;endll; return; &#125; register int mid = (L + R) &gt;&gt; 1; if (l&lt;=mid &amp;&amp; dat[rt&lt;&lt;1].mxx &gt;1) change (rt&lt;&lt;1, l, r); if (mid&lt; r &amp;&amp; dat[rt&lt;&lt;1|1].mxx&gt;1) change (rt&lt;&lt;1|1,l,r); update (rt);&#125;//using namespace fastIO;inline void Write (const int&amp; x, const int&amp; y) &#123;cout &lt;&lt; query(1, x, y) &lt;&lt; endll;&#125;inline void Change (const int&amp; x, const int&amp; y) &#123;change (1, x, y);&#125;int main ()&#123; register int _ = 0, n; while (scanf (\"%d\", &amp;n) != EOF) &#123; fastIO::cout &lt;&lt; \"Case #\" &lt;&lt; ++ _ &lt;&lt; \":\" &lt;&lt; endll; build (root); register int m, x, y, ret; register bool opt; fastIO::cin &gt;&gt; m; while (m --) &#123; fastIO::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (x &gt; y) swap (x, y); opt? Write(x, y):Change (x, y); &#125; putchar ('\\n'); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"SP1716 GSS3 - Can you answer these queries III","slug":"GSS3","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:31:22.545Z","comments":true,"path":"GSS3/","link":"","permalink":"https://novaellias.github.io/GSS3/","excerpt":"GSS3 - Can you answer these queries III","text":"GSS3 - Can you answer these queries III LuoguVjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define rint register intint n, m, x, y, in, opt;struct node &#123; int sum, lmax, rmax, dat, l, r;&#125; tr[200001];namespace FastIO &#123; const int str=1&lt;&lt;20; const char* endl=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;(c&lt;'0'||c&gt;'9'))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;inline const int&amp; max(const int&amp; x,const int&amp; y) &#123; return x&gt;y?x:y;&#125;inline void update (int rt) &#123; tr[rt].sum =tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum; tr[rt].lmax= max (tr[rt&lt;&lt;1].lmax, tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].lmax); tr[rt].rmax= max (tr[rt&lt;&lt;1|1].rmax, tr[rt&lt;&lt;1|1].sum + tr[rt&lt;&lt;1].rmax); tr[rt].dat = max (max(tr[rt&lt;&lt;1].dat, tr[rt&lt;&lt;1|1].dat), tr[rt&lt;&lt;1].rmax + tr[rt&lt;&lt;1|1].lmax);&#125;inline void build (int rt,int l,int r) &#123; tr[rt].l = l, tr[rt].r = r; if(l==r) &#123; FastIO::cin&gt;&gt;in; tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = in; return; &#125; int mid = (l+r)&gt;&gt;1; build (lson); build (rson); update (rt);&#125;inline node query (int rt, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; int mid = (l+r)&gt;&gt;1; if (ql &gt; mid) return query (rson, ql, qr); if (qr &lt;= mid) return query (lson, ql, qr); else &#123; node ans,a,b; a = query (lson,ql,qr); b = query (rson,ql,qr); ans.sum = a.sum + b.sum; ans.dat = max (a.dat, a.rmax + b.lmax), ans.dat = max (ans.dat, b.dat); ans.lmax= max (a.lmax, a.sum + b.lmax); ans.rmax= max (b.rmax, b.sum + a.rmax); return ans; &#125;&#125;inline void work (int rt, int to, int val)&#123; if (tr[rt].l == tr[rt].r) &#123; tr[rt].sum = tr[rt].lmax = tr[rt].rmax = tr[rt].dat = val; return; &#125; register int mid = (tr[rt].l + tr[rt].r) &gt;&gt; 1; if (to &lt;= mid) work (rt&lt;&lt;1, to, val); else work (rt&lt;&lt;1|1, to, val); update(rt);&#125;using namespace FastIO;int main ()&#123; //freopen (\"nico.in\",\"r\",stdin); cin &gt;&gt; n; build (1, 1, n); cin &gt;&gt; m; while (m --) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (opt) cout &lt;&lt; query (1, 1, n, x, y).dat &lt;&lt; endl; else work (1,x,y); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"SP2916 GSS5 - Can you answer these queries V","slug":"GSS5","date":"2018-11-02T02:08:23.000Z","updated":"2020-02-13T14:46:22.452Z","comments":true,"path":"GSS5/","link":"","permalink":"https://novaellias.github.io/GSS5/","excerpt":"GSS4 - Can you answer these queries V","text":"GSS4 - Can you answer these queries V LuoguVjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#pragma GCC optimize (2)#pragma G++ optimize (2)#pragma GCC optimize (3)#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\")#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS], *p1 = buf, *p2 = buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = 0; while (c &lt; '0' || c &gt; '9') &#123;if (c == '-') m = true; c = gc();&#125; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x)&#123; if (x &lt; 0ll) putchar('-'), x = -x; write (x), putchar ('\\n');&#125;#define Re register#define maxn 10001#define dmax 40001#define swap(x,y) ((y)^=(x)^=(y)^=(x)) struct node &#123; int l, r; long long sum, lmax, rmax, dat;&#125; tr[dmax], null;inline const long long&amp; max (const long long&amp; x,const long long&amp; y) &#123;return x&gt;y? x:y;&#125;inline void update (int rt)&#123; register int lson = rt&lt;&lt;1, rson = rt&lt;&lt;1|1; tr[rt].sum = tr[lson].sum + tr[rson].sum; tr[rt].lmax= max (tr[lson].lmax, tr[lson].sum + tr[rson].lmax); tr[rt].rmax= max (tr[rson].rmax, tr[rson].sum + tr[lson].rmax); tr[rt].dat = max (max(tr[lson].dat, tr[rson].dat), tr[lson].rmax + tr[rson].lmax);&#125;static void build (int rt, int l, int r) &#123; tr[rt].l = l, tr[rt].r = r; if (l == r) &#123;tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = read (); return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid + 1, r); update (rt);&#125;static node query (int rt, int ql, int qr) &#123; register int l = tr[rt].l, r = tr[rt].r; if (ql &gt; qr) return null; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; register int mid = (l + r) &gt;&gt; 1; if (ql &gt; mid) return query (rt&lt;&lt;1|1,ql,qr); if (qr &lt;= mid) return query (rt&lt;&lt;1, ql, qr); else &#123; register node ret, a, b; a = query (rt&lt;&lt;1, ql, qr), b = query (rt&lt;&lt;1|1, ql, qr); ret.sum = a.sum + b.sum; ret.dat = max (a.dat, a.rmax + b.lmax), ret.dat = max (ret.dat, b.dat); ret.lmax= max (a.lmax, a.sum + b.lmax), ret.rmax= max (b.rmax, b.sum + a.rmax); return ret; &#125;&#125;static void modify (int rt, int to, long long val)&#123; if (tr[rt].l == tr[rt].r) &#123;tr[rt].sum = tr[rt].lmax = tr[rt].rmax = tr[rt].dat = val; return;&#125; register int mid = (tr[rt].l + tr[rt].r) &gt;&gt; 1; if (to &lt;= mid) modify (rt&lt;&lt;1, to, val); else modify (rt&lt;&lt;1|1, to, val); update(rt);&#125;int main() &#123; register int _ = read (); register int x1, y1, x2, y2; register int n, m; register node a, b, c; register long long tmp; register char opt; while (_ --) &#123; n = read ();//, m = read (); build (1, 1, n); m = read (); while (m --) &#123; //opt = 'z'; //while ((opt ^ 'C') &amp;&amp; (opt ^ 'Q')) opt = gc(); //if (opt ^ 'C') &#123; x1 = read (), y1 = read (), x2 = read (), y2 = read (); if (y1&lt;x1) swap(x1,y1); if (y2&lt;x2) swap(x2,y2); if (x1&gt;y2) swap(x1,x2), swap(y1,y2); if (y1 &lt; x2) &#123; writelen (max(query(1,x1,y1-1).rmax, 0) + query(1,y1,x2).sum + max(query(1,x2+1,y2).lmax, 0)); &#125; else &#123; a = query (1, x2, y1), b = query(1,x1,x2-1), c = query(1,y1+1,y2); tmp = a.dat; tmp = max (tmp, a.lmax + b.rmax); tmp = max (tmp, c.lmax + a.rmax); tmp = max (tmp, a.sum + max(0, b.rmax) + max(0, c.lmax)); writelen (tmp); &#125; &#125; //else &#123;x1 = read (), tmp = read (); modify (1, x1, tmp);&#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"Nescafé17 守卫者的挑战","slug":"Nescafe17-Defenders'-Challenge","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:32:24.468Z","comments":true,"path":"Nescafe17-Defenders'-Challenge/","link":"","permalink":"https://novaellias.github.io/Nescafe17-Defenders'-Challenge/","excerpt":"Nescafé17 守卫者的挑战","text":"Nescafé17 守卫者的挑战 守卫者的挑战[Description]打开了黑魔法师Vani的大门,队员们在迷宫般的路上漫无目的地搜寻着关押applepi的监狱的所在地.突然,眼前一道亮光闪过.“我,Nizem,是黑魔法圣殿的守卫者.如果你能通过我的挑战,那么你可以带走黑魔法圣殿的地图……”瞬间,队员们被传送到了一个擂台上,最初身边有一个容量为K的包包. 擂台赛一共有项挑战,各项挑战依次进行.第项挑战有一个属性ai,如果ai≥0,表示这次挑战成功后可以再获得一个容量为ai的包包；如果ai = -1,则表示这次挑战成功后可以得到一个大小为 1 的地图残片.地图残片必须装在包包里才能带出擂台,包包没有必要全部装满,但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑,只需要完成所有N项挑战后背包容量足够容纳地图残片即可）,才能拼出完整的地图.并且他们至少要挑战成功L次才能离开擂台. 队员们一筹莫展之时,善良的守卫者Nizem帮忙预估出了每项挑战成功的概率,其中第i项挑战成功的概率为pi%.现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率. [Data Size]对于 100% 的数据,保证 $ 0≤K≤2000$ , $ 0≤N≤200$ , $-1≤ai≤1000$ , $0≤L≤N$ , $0≤pi≤100$ . [Solution]刚看到此题时,我被那个概率吓得半死.但看了数据范围,此题就是一道很简单的水题了. 对于可以赢l把以上并且背包不会溢出的概率 $P_0$ ,通过枚举结束时的背包容量和赢的次数快速求出: $$ P_0=\\sum_{i=l}^{n}\\sum_{j=0}^{K}P_{i, j} $$ 而 $P_{i, j}$ 可以通过刷表法 $O(n^2K)≈8*10^7$ 地求出: 定义状态 $dp[i][j][k]$ 代表达到第$i$场胜$j$场背包容量为$k$时的概率,转移方程很显然为本次成功的概率和本次失败的概率之和: 123dp[i][j][k] += dp[i-1][j][k] * (1 - dat[i].dat);if ((tmp = min (K + dat[i].opt, n)) &lt; 0) continue;dp[i][j+1][tmp] += dp[i-1][j][k] * dat[i].dat; 这个时间复杂度看起来很悬,未免会有稍作优化的想法.本题K的范围2000,但是真的需要2000吗?共有N项挑战,对于每一项挑战最多可以获得一块地图残片,所以背包实际的最大容量就是N次挑战中所有类型-1的数量,极限情况下是n,这样复杂度就会降到 $O(n^3)$, 较为稳妥. [Code]考场代码,写得略丑,请谅解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#pragma G++ optimize (3)#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;inline double getdou ()&#123; register double x=0; register char c = gc (); while (c &lt; '0' || c &gt; '9') c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = x * 10 + (c^'0'), c = gc(); if (c == '.') &#123; register double s = 0.1, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = x + (c-'0')*s, s/=10, c = gc (); &#125; return x;&#125;inline const int&amp; min (const int&amp; a, const int&amp; b)&#123;return a&lt;b? a:b;&#125;#define Re registerstruct node &#123; int opt; double dat;&#125; dat[201];inline bool cmp (node a, node b) &#123;return a.opt &gt; b.opt;&#125;double dp[201][201][201];signed main ()&#123; freopen (\"guard.in\", \"r\", stdin); freopen (\"guard.out\",\"w\",stdout); register int n = read (), l = read (), k = read (), tmp; for (Re int i = 1; i &lt;= n; ++ i) dat[i].dat = getdou()/100; for (Re int i = 1; i &lt;= n; ++ i) dat[i].opt = read (); std::sort (dat + 1, dat + n + 1, cmp); dp[0][0][min(n, k)] = 1.0; for (Re int i = 1; i &lt;= n; ++ i) &#123; for (Re int j = 0; j &lt;= i; ++ j) &#123; for (Re int K = 0; K &lt;= n; ++ K) &#123; dp[i][j][K] += dp[i-1][j][K] * (1 - dat[i].dat); if ((tmp = min (K + dat[i].opt, n)) &lt; 0) continue; dp[i][j+1][tmp] += dp[i-1][j][K] * dat[i].dat; &#125; &#125; &#125; register double ans = 0.0; for (Re int i = l; i &lt;= n; ++ i) for (Re int j = 0; j &lt;= n; ++ j) ans += dp[n][i][j]; printf (\"%.6lf\", ans); fclose (stdin), fclose (stdout); return 0;&#125; Cena评测$0.03s$,效率还是可以的.","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"contest","slug":"contest","permalink":"https://novaellias.github.io/tags/contest/"},{"name":"DP","slug":"DP","permalink":"https://novaellias.github.io/tags/DP/"}]},{"title":"STL 洛谷P3369 普通平衡树","slug":"lg-P3369-STL","date":"2018-10-30T08:31:14.000Z","updated":"2019-06-10T11:32:01.705Z","comments":true,"path":"lg-P3369-STL/","link":"","permalink":"https://novaellias.github.io/lg-P3369-STL/","excerpt":"luogu P3369 普通平衡树","text":"luogu P3369 普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; c ^ '-') c = gc(); if (c == '-') m = true, c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0) x=-x, putchar('-');write (x);putchar ('\\n');&#125;vector &lt;int&gt; eli;signed main ()&#123; register int n = read (), x, opt; while (n --) &#123; opt = read (), x = read (); if (opt == 1) eli.insert(upper_bound(eli.begin(), eli.end(), x), x); else if (opt == 2) eli.erase(lower_bound(eli.begin(), eli.end(), x)); else if (opt == 3) writelen(lower_bound(eli.begin(), eli.end(), x)-eli.begin()+1); else if (opt == 4) writelen(eli[x - 1]); else if (opt == 5) writelen(*--lower_bound(eli.begin(), eli.end(), x)); else if (opt == 6) writelen(*upper_bound(eli.begin(), eli.end(), x)); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"https://novaellias.github.io/tags/Template/"},{"name":"STL","slug":"STL","permalink":"https://novaellias.github.io/tags/STL/"}]},{"title":"洛谷 线段树模板","slug":"luogu-segment-tree","date":"2018-06-08T11:29:26.000Z","updated":"2019-06-10T11:32:20.647Z","comments":true,"path":"luogu-segment-tree/","link":"","permalink":"https://novaellias.github.io/luogu-segment-tree/","excerpt":"洛谷 线段树1 线段树2 模板","text":"洛谷 线段树1 线段树2 模板 P3372 [模板] 线段树 1Luogu P3372 线段树加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma GCC optimize (2)//...略#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;#define Re register#define maxn 100001#define dmax 400001typedef long long ll;#define swap(x,y) ((x)^=(y)^=(x)^=(y))struct SMT &#123; int l, r; long long sum, tag;&#125; tr[dmax];inline void update (Re int rt) &#123; tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;&#125;static void build (Re int rt, Re int l, Re int r)&#123; tr[rt].l = l, tr[rt].r = r; if (l == r) &#123;tr[rt].sum = read(); return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid+1, r); update (rt);&#125;inline void pushdown (Re int rt)&#123; if (rt &gt; 200000 || !tr[rt].tag) return; register int ls = rt&lt;&lt;1, rs = rt&lt;&lt;1|1; tr[ls].tag += tr[rt].tag, tr[rs].tag += tr[rt].tag; tr[ls].sum += tr[rt].tag * (tr[ls].r - tr[ls].l + 1), tr[rs].sum += tr[rt].tag * (tr[rs].r - tr[rs].l + 1); tr[rt].tag = 0;&#125;static void modify (Re int rt, Re int l, Re int r, Re ll val)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; tr[rt].sum += val * (R - L + 1), tr[rt].tag += val; return; &#125; register int mid = (L + R) &gt;&gt; 1; pushdown (rt); if (l &lt;= mid) modify (rt&lt;&lt;1, l, r, val); if (r &gt; mid) modify (rt&lt;&lt;1|1,l,r, val); update (rt);&#125;static long long query (Re int rt, Re int l, Re int r)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].sum; pushdown (rt); register int mid = (L+R)&gt;&gt;1; register long long ret = 0; if (l &lt;= mid) ret = query (rt&lt;&lt;1, l, r); if (r &gt; mid) ret += query (rt&lt;&lt;1|1,l,r); return ret;&#125;signed main ()&#123; register int n=read(), m=read(); register int opt, x, y; register long long z; build (1, 1, n); while (m --) &#123; opt=read(), x=read(), y=read(); if (x &gt; y) swap (x, y); if (opt == 2) writelen (query (1, x, y)); else z = read (), modify (1, x, y, z); &#125; return 0;&#125; P3373 [模板]线段树 2Luogu P3372 加 乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#pragma GCC optimize (2)//..略#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;inline long long mul_mod (register long long a,register long long b,register long long mo) &#123; register long long ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\" : \"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo)); return ret;&#125;#define Re register#define maxn 100001#define dmax 400001typedef long long ll;#define swap(x,y) ((x)^=(y)^=(x)^=(y))#define mod(x) (((x)%modn+modn)%modn)long long modn;struct SMT &#123; int l, r; long long sum, add, mul;&#125; tr[dmax];inline void update (Re int rt) &#123; tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;&#125;static void build (Re int rt, Re int l, Re int r)&#123; tr[rt] = &#123;l, r, 0ll, 0ll, 1ll&#125;; if (l == r) &#123;tr[rt].sum = read()%modn; return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid+1, r); update (rt);&#125;inline void pushdown (Re int rt)&#123; if (rt &gt; 200000 || (!tr[rt].add &amp;&amp; tr[rt].mul == 1ll)) return; register int ls = rt &lt;&lt; 1, rs = rt &lt;&lt; 1 | 1; tr[ls].mul = mul_mod (tr[ls].mul, tr[rt].mul, modn); tr[rs].mul = mul_mod (tr[rs].mul, tr[rt].mul, modn); tr[ls].add = mod (mul_mod (tr[ls].add , tr[rt].mul, modn) + tr[rt].add); tr[rs].add = mod (mul_mod (tr[rs].add, tr[rt].mul, modn) + tr[rt].add); tr[ls].sum = mod (mul_mod (tr[ls].sum, tr[rt].mul, modn) + mul_mod (tr[rt].add, (tr[ls].r - tr[ls].l + 1), modn)); tr[rs].sum = mod (mul_mod (tr[rs].sum, tr[rt].mul, modn) + mul_mod (tr[rt].add, (tr[rs].r - tr[rs].l + 1), modn)); tr[rt].add = 0ll, tr[rt].mul = 1ll;&#125;// opt==1: mul opt==2: addstatic void modify (Re int rt, Re int l, Re int r, Re ll val, Re int opt)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; if (opt == 2) &#123; tr[rt].add = mod (tr[rt].add + val),\\ tr[rt].sum = mod (tr[rt].sum + mul_mod (val, (R - L + 1), modn)); return; &#125; else &#123; tr[rt].mul = mul_mod (tr[rt].mul, val, modn),\\ tr[rt].sum = mul_mod (tr[rt].sum, val, modn),\\ tr[rt].add = mul_mod (tr[rt].add, val, modn); return; &#125; &#125; pushdown (rt); register int mid = (L + R) &gt;&gt; 1; if (l &lt;= mid) modify (rt&lt;&lt;1, l, r, val, opt); if (r &gt; mid) modify (rt&lt;&lt;1|1,l,r, val, opt); update (rt);&#125;static long long query (Re int rt, Re int l, Re int r)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].sum; pushdown (rt); register int mid = (L+R)&gt;&gt;1; register long long ret = 0; if (l &lt;= mid) ret = query (rt&lt;&lt;1, l, r); if (r &gt; mid) ret += query (rt&lt;&lt;1|1,l,r); return ret % modn;&#125;signed main ()&#123; register int n=read(), m=read(); modn=read(); register int opt, x, y; register long long z; build (1, 1, n); while (m --) &#123; opt=read(), x=read(), y=read(); if (x &gt; y) swap (x, y); if (opt == 3) writelen (query (1,x,y)); else z=read()%modn,modify(1,x,y,z,opt); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"},{"name":"Template","slug":"Template","permalink":"https://novaellias.github.io/tags/Template/"}]},{"title":"最短路模板","slug":"shortest-path","date":"2017-12-05T06:47:00.000Z","updated":"2019-06-10T11:32:38.796Z","comments":true,"path":"shortest-path/","link":"","permalink":"https://novaellias.github.io/shortest-path/","excerpt":"SPFA 堆优化迪杰斯特拉C++模板","text":"SPFA 堆优化迪杰斯特拉C++模板 SPFALuogu P3371 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma G++ optimize (3)#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; c ^ '-') c = gc(); if (c == '-') m = true, c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;inline const int&amp; min (const int&amp; a, const int&amp; b) &#123;return a&lt;b? a:b;&#125;#define Re register#define maxn 10001#define maxm 500001int head[maxn], nxt[maxm], too[maxm], ecnt;long long wei[maxm], dis[maxn];int que[maxm*100 + 100];bool vis[maxn];signed main ()&#123; register int n = read (), m = read (), sta = read (); for (Re int i = 1; i &lt;= n; ++ i) dis[i] = 2147483647; register int fr, to, va; while (m --) &#123; fr = read (), to = read (), va = read (); nxt[++ ecnt] = head[fr], head[fr] = ecnt, too[ecnt] = to, wei[ecnt] = va; &#125; dis[sta] = 0; register int hd = 0, tl = 1; que[tl] = sta; while (hd &lt; tl) &#123; fr = que[++ hd], vis[fr] = false; for (Re int i = head[fr]; i; i = nxt[i]) &#123; to = too[i], va = wei[i]; if (dis[to] &gt; dis[fr] + va) &#123; dis[to] = dis[fr] + va; if (!vis[to]) vis[to] = true, que[++ tl] = to; &#125; &#125; &#125; for (Re int i = 1; i &lt;= n; ++ i) &#123; if (dis[i]&lt;0) dis[i] = -dis[i], putchar ('-'); write (dis[i]), putchar (' '); &#125; return 0;&#125; 堆优化迪杰斯特拉Luogu P4779 OLD (2017)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"avx\",\"sse2\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;#define maxn 100001#define maxm 200001#define inff 2147483647inline int read () &#123; int x = 0; char c = getchar(); bool m = false; while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') c = getchar(), m = true; while (isdigit(c)) x = x * 10 + c - 48, c = getchar(); if (m) return -x; else return x;&#125;inline void fastwrite (int x) &#123; if(x &lt; 0) x = -x, putchar('-'); if(x &gt; 9) fastwrite(x / 10); putchar(x%10 + '0');&#125;inline void fastwritespace (int x) &#123; fastwrite(x); putchar(' ');&#125;struct node &#123; int val, name;&#125;;struct cmp &#123; inline bool operator() (const node&amp; aa, const node&amp; bb) &#123; return aa.val &gt; bb.val; &#125;&#125;;int n, m, s, fro, to, w;int dis[maxn];bool visit[maxn];vector &lt;pair &lt;int, int&gt; &gt; data[maxn];__gnu_pbds::priority_queue &lt;node, cmp, pairing_heap_tag&gt; nico;int main () &#123; n = read (), m = read (), s = read (); for (int i = 1; i &lt;= m; i ++) &#123; fro = read (), to = read (), w = read (); data[fro].push_back (make_pair (to, w)); &#125; for (int i = 1; i &lt;= n; i ++) dis[i] = inff; dis[s] = 0; nico.push ((node) &#123; 0, s &#125;); while (!nico.empty ()) &#123; fro = nico.top ().name; nico.pop (); if (visit[fro]) continue; visit[fro] = true; for (int i = 0; i &lt; data[fro].size (); i ++) &#123; to = data[fro][i].first; w = data[fro][i].second; if (!visit[to] &amp;&amp; dis[fro] + w &lt; dis[to]) &#123; dis[to] = dis[fro] + w; nico.push ((node) &#123; dis[to], to &#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i ++) fastwritespace (dis[i]); return 0;&#125; NEW(2018/11/5)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#pragma G++ optimize (3)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using std::priority_queue;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void nwrite (int x) &#123;write (x); putchar (' ');&#125;#define maxn 100001#define maxm 200001#define Re registerstruct node &#123; int id, val; friend bool operator &lt; (node a, node b) &#123; return a.val &gt; b.val; &#125;&#125;;priority_queue &lt;node&gt; que;int head[maxn], wei[maxm], too[maxm], nxt[maxm], ecnt;bool vis[maxn];int dis[maxn];signed main ()&#123; register int n = read (), m = read (), sta = read (); register int fr, to, va; while (m --) &#123; fr = read (), nxt[++ ecnt] = head[fr],\\ head[fr] = ecnt, too[ecnt] = read (), wei[ecnt] = read (); &#125; memset (dis, 0x3f3f3f3f, sizeof dis); dis[sta] = 0; que.push (&#123;sta, 0&#125;); while (!que.empty ()) &#123; fr = que.top ().id, que.pop (); if (!vis[fr]) &#123; vis[fr] = true; for (Re int i = head[fr]; i; i = nxt[i]) &#123; to = too[i], va = wei[i]; if (dis[fr] + va &lt; dis[to]) &#123; dis[to] = dis[fr] + va; que.push (&#123;to, dis[to]&#125;); &#125; &#125; &#125; &#125; for (Re int i = 1; i &lt;= n; ++ i) nwrite (dis[i]); return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"https://novaellias.github.io/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"https://novaellias.github.io/tags/Template/"},{"name":"最短路","slug":"最短路","permalink":"https://novaellias.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"HEXO博客的基本搭建","slug":"hexo-buildup","date":"2017-11-13T03:10:00.000Z","updated":"2019-06-10T11:23:15.145Z","comments":true,"path":"hexo-buildup/","link":"","permalink":"https://novaellias.github.io/hexo-buildup/","excerpt":"HEXO博客的基本搭建 安装 初始化 部署","text":"HEXO博客的基本搭建 安装 初始化 部署 事前准备准备仓库在GitHub上注册账号并创建仓库yourname.github.io 安装必要环境安装node.js及git 完成后在命令窗口分别输入 123node -vnpm -vgit- version 如显示正确版本号即为成功. SSH授权在目录下右键,git bash 1ssh-keygen -t rsa 在C盘用户目录下用记事本打开公钥,复制内容添加到GitHub. 在git bash中输入 1ssh -T git@github.com 测试是否成功. 安装及运行安装和初始化HEXO1234$ npm install hexo-cli -g$ hexo init$ hexo g$ hexo s HEXO命令一览12345678910111213141516171819202122Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on console","categories":[{"name":"IT","slug":"IT","permalink":"https://novaellias.github.io/categories/IT/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://novaellias.github.io/tags/HEXO/"}]}]}