{"meta":{"title":"Next Dream...","subtitle":null,"description":null,"author":"ELLIAS","url":"brynhild.online","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-10T09:02:51.293Z","updated":"2019-06-05T11:45:47.777Z","comments":true,"path":"404.html","permalink":"brynhild.online/404.html","excerpt":"","text":"404 Not Found This object has escaped into fantasy Please contact the Administrator"},{"title":"","date":"2020-03-08T12:26:06.703Z","updated":"2020-03-08T12:26:06.703Z","comments":true,"path":"baidu_verify_oFoINJ957S.html","permalink":"brynhild.online/baidu_verify_oFoINJ957S.html","excerpt":"","text":"oFoINJ957S"},{"title":"","date":"2020-03-08T12:25:36.712Z","updated":"2019-06-01T11:31:37.462Z","comments":true,"path":"googleee23d67b90dfc2e5.html","permalink":"brynhild.online/googleee23d67b90dfc2e5.html","excerpt":"","text":"google-site-verification: googleee23d67b90dfc2e5.html"},{"title":"","date":"2020-03-09T11:18:21.296Z","updated":"2020-03-09T11:18:16.133Z","comments":true,"path":"archives/index.html","permalink":"brynhild.online/archives/index.html","excerpt":"","text":""},{"title":"About","date":"2020-03-09T08:15:27.346Z","updated":"2020-03-09T08:15:27.346Z","comments":true,"path":"about/index.html","permalink":"brynhild.online/about/index.html","excerpt":"","text":"Information ID: Kishin ELLIAS school: DLYMGZ AFO: @NOIp2018 Contact Me Luogu: 65678 Malody: Ellias_K WeChat : QQ: 3218673140 Email: eternalkiri@outlook.com"},{"title":"archives","date":"2020-03-09T11:24:37.000Z","updated":"2020-03-09T11:24:37.942Z","comments":true,"path":"archives/index-1.html","permalink":"brynhild.online/archives/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-05T11:25:35.240Z","updated":"2019-06-05T11:25:35.240Z","comments":true,"path":"categories/index.html","permalink":"brynhild.online/categories/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-02-17T03:40:30.560Z","updated":"2019-06-15T11:22:42.721Z","comments":true,"path":"friends/index.html","permalink":"brynhild.online/friends/index.html","excerpt":"","text":""},{"title":"Hidden List","date":"2020-03-16T06:30:26.279Z","updated":"2020-03-16T06:30:26.279Z","comments":true,"path":"hiddenlist/index.html","permalink":"brynhild.online/hiddenlist/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-05T11:26:48.096Z","updated":"2019-06-05T11:26:48.096Z","comments":true,"path":"tags/index.html","permalink":"brynhild.online/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-12T02:17:10.349Z","updated":"2020-03-12T02:17:10.349Z","comments":true,"path":"jigokutsushin/mid/index.html","permalink":"brynhild.online/jigokutsushin/mid/index.html","excerpt":"","text":"地獄通信 Not Found あなたの怨み、晴らします。 この怨み、地狱へ流します！"},{"title":"","date":"2020-03-11T11:40:28.902Z","updated":"2020-03-11T11:40:28.902Z","comments":true,"path":"jigokutsushin/night/index.html","permalink":"brynhild.online/jigokutsushin/night/index.html","excerpt":"","text":"地獄通信 Not Found あなたの怨み、晴らします。 この怨み、地狱へ流します！"},{"title":"","date":"2020-03-11T11:39:36.367Z","updated":"2020-03-11T11:39:36.367Z","comments":true,"path":"jigokutsushin/full/index.html","permalink":"brynhild.online/jigokutsushin/full/index.html","excerpt":"","text":"地獄通信 Not Found あなたの怨み、晴らします。 この怨み、地狱へ流します！"},{"title":"NICO LOOPER","date":"2018-12-11T02:08:23.000Z","updated":"2020-03-12T02:17:41.251Z","comments":true,"path":"tools/niconi/index.html","permalink":"brynhild.online/tools/niconi/index.html","excerpt":"","text":"window.onload = function () { var local1 = document.getElementById('videoID'); local1.autoplay = true; local1.loop = true; local1.muted = false; if (local1.paused) { local1.play(); } else { local1.pause(); } }"},{"title":"","date":"2020-03-13T02:08:05.073Z","updated":"2020-03-13T02:08:05.073Z","comments":true,"path":"tools/2048/index.html","permalink":"brynhild.online/tools/2048/index.html","excerpt":"","text":"2048 2048 Welcome! BEST: 0 SCORE: 0 GAME OVERRETRY RESTART"},{"title":"","date":"2020-03-13T02:47:04.041Z","updated":"2020-03-13T02:47:04.041Z","comments":true,"path":"tools/pac-man/index.html","permalink":"brynhild.online/tools/pac-man/index.html","excerpt":"","text":"Pac-Man body { background-color: #292929 } * { padding: 0; margin: 0; } .wrapper { width: 960px; margin: 0 auto; line-height: 36px; text-align: center; color: #999; } canvas { display: block; background: #000; } .mod-botton { height: 32px; padding: 15px 0; text-align: center; } unavailable. Press [space] or [enter] to pause or continue."},{"title":"","date":"2020-03-16T06:10:47.787Z","updated":"2020-03-16T06:10:47.787Z","comments":true,"path":"tools/minesweeper/minesweeper-adv/index.html","permalink":"brynhild.online/tools/minesweeper/minesweeper-adv/index.html","excerpt":"","text":"Minesweeper Minesweeper Setting Easy Normal Hard Lunatic custome var mine1; window.onload = function () { document.getElementsByClassName('mine-wrap')[0].style.display = \"block\"; mine1 = new Mine(\"mine1\", 'face', 30, 16, 99, \"game-tag-images\", \"game-time-images\"); mine1.init(); var inputEle = document.getElementsByTagName('input'); for (var i = 0; i < inputEle.length; i++) { inputEle[i].onclick = function () { var width, height, minenum; if (this.value == 0) { width = 9; height = 9; minenum = 10; } else if (this.value == 1) { width = 16; height = 16; minenum = 40; } else if (this.value == 2) { width = 30; height = 16; minenum = 99; } else if (this.value == 4) { width = 30; height = 24; minenum = 160; } else if (this.value == 3) { width = prompt(\"line: (9-30)\"); height = width && prompt(\"row: (9-24)\"); minenum = height && prompt(\"boom: (10-200)\"); if (!(width && height && minenum)) { return; } if (width < 9) { width = 9; } if (width > 30) { width = 30; } if (height < 9) { height = 9; } if (height > 24) { height = 24; } if (minenum < 10) { minenum = 10; } if (minenum > 200) { minenum = 200; } if (minenum > height * width) { minenum = 10; } } mine1.paneheight = height; mine1.panewidth = width; mine1.minenum = minenum; mine1.init(); document.getElementsByClassName(\"mine-wrap\")[0].style.width = width * mine1.PANE_SIZE + 25 + \"px\"; } }; }"},{"title":"","date":"2020-03-16T05:53:57.113Z","updated":"2020-03-16T05:53:57.113Z","comments":true,"path":"tools/minesweeper/minesweeper-pri/index.html","permalink":"brynhild.online/tools/minesweeper/minesweeper-pri/index.html","excerpt":"","text":"Minesweeper #bar { text-align: center; margin-bottom: 20px; } .bar { height: 25px; width: 150px; line-height: 25px; display: inline-block; border: solid 1px #000; margin-left: 20px; margin-right: 20px; } #grid { margin: auto; } .blocks { width: 30px; height: 30px; line-height: 30px; display: block; text-align: center; border: solid 1px #000; user-select: none; cursor: pointer; } .blocks:hover { background: #0af; } Left: 0 Time: 0s var row = 10; var col = 10; var maxCount = 10; var isFirstOpen = true; var grid = init_grid(); var count = document.getElementById('count'); var time = document.getElementById('time'); count.innerHTML = maxCount; var timer = setInterval(function () { let seconds = (parseFloat(time.innerHTML) + 0.1).toFixed(1); time.innerHTML = seconds; }, 100) function init_grid() { let gridHtml = ''; for (let i = 0; i < row; i++) { gridHtml += '' for (let j = 0; j < col; j++) { gridHtml += ''; } gridHtml += '' } document.getElementById('grid').innerHTML = gridHtml; let blocks = document.getElementsByClassName('blocks'); let grid = new Array(); for (let i = 0; i < blocks.length; i++) { if (i % col === 0) { grid.push(new Array()); } blocks[i].count = 0; grid[parseInt(i / col)].push(blocks[i]); } return grid; } function block_click(_i, _j, e) { if (grid[_i][_j].isOpen) { return; } if (e.button === 0) { if (isFirstOpen) { isFirstOpen = false; let count = 0; while (count < maxCount) { let ri = Math.floor(Math.random() * row); let rj = Math.floor(Math.random() * col); if (!(ri === _i && rj === _j) && !grid[ri][rj].isMine) { grid[ri][rj].isMine = true; count++; for (let i = ri - 1; i < ri + 2; i++) { for (let j = rj - 1; j < rj + 2; j++) { if (i > -1 && j > -1 && i < row && j < col) { grid[i][j].count++; } } } } } } block_open(_i, _j); function block_open(_i, _j) { let block = grid[_i][_j]; op(block); function op(block) { block.isOpen = true; block.style.background = '#ccc'; block.style.cursor = 'default'; } if (block.isMine) { block.innerHTML = '雷'; for (let i = 0; i < row; i++) { for (let j = 0; j < col; j++) { block = grid[i][j]; if (!block.isOpen && block.isMine) { op(block); block.innerHTML = '雷'; } } } clearInterval(timer); alert(\"GAME OVER\"); } else if (block.count === 0) { for (let i = _i - 1; i < _i + 2; i++) { for (let j = _j - 1; j < _j + 2; j++) { if (i > -1 && j > -1 && i < row && j < col && !grid[i][j].isOpen && !grid[i][j] .ismine) { block_open(i, j); } } } } else { block.innerHTML = block.count; } } } else if (e.button === 2) { let block = grid[_i][_j]; if (block.innerHTML !== '▲') { count.innerHTML = parseInt(count.innerHTML) - 1; block.innerHTML = '▲'; } else { block.innerHTML = ''; count.innerHTML = parseInt(count.innerHTML) + 1; } } for (let i = 0; i < row; i++) { for (let j = 0; j < col; j++) { if (!grid[i][j].isMine && !grid[i][j].isOpen) { return; } } } clearInterval(timer); alert(\"YOU WIN!\"); }"},{"title":"","date":"2020-03-16T06:11:03.181Z","updated":"2020-03-16T06:10:41.264Z","comments":true,"path":"tools/minesweeper/minesweeper-adv/test.html","permalink":"brynhild.online/tools/minesweeper/minesweeper-adv/test.html","excerpt":"","text":"Minesweeper Minesweeper Setting Easy Normal Hard Lunatic custome var mine1; window.onload = function () { document.getElementsByClassName('mine-wrap')[0].style.display = \"block\"; mine1 = new Mine(\"mine1\", 'face', 30, 16, 99, \"game-tag-images\", \"game-time-images\"); mine1.init(); var inputEle = document.getElementsByTagName('input'); for (var i = 0; i < inputEle.length; i++) { inputEle[i].onclick = function () { var width, height, minenum; if (this.value == 0) { width = 9; height = 9; minenum = 10; } else if (this.value == 1) { width = 16; height = 16; minenum = 40; } else if (this.value == 2) { width = 30; height = 16; minenum = 99; } else if (this.value == 3) { width = 30; height = 24; minenum = 160; } else if (this.value == 4) { width = prompt(\"line: (9-30)\"); height = width && prompt(\"row: (9-24)\"); minenum = height && prompt(\"mine: (10-200)\"); if (!(width && height && minenum)) { return; } if (width < 9) { width = 9; } if (width > 30) { width = 30; } if (height < 9) { height = 9; } if (height > 24) { height = 24; } if (minenum < 10) { minenum = 10; } if (minenum > 200) { minenum = 200; } if (minenum > height * width) { minenum = 10; } } mine1.paneheight = height; mine1.panewidth = width; mine1.minenum = minenum; mine1.init(); document.getElementsByClassName(\"mine-wrap\")[0].style.width = width * mine1.PANE_SIZE + 25 + \"px\"; } }; }"},{"title":"Tetris 3D","date":"2019-07-06T15:20:12.000Z","updated":"2020-03-13T15:42:41.868Z","comments":true,"path":"tools/tetris/tetris3d/index.html","permalink":"brynhild.online/tools/tetris/tetris3d/index.html","excerpt":"","text":"Tetris 3D #container{margin:0 auto;text-align:center;} .cyr{text-align:center;} Loading game... How to play Use the arrow keys to guide the falling blocks, spacebar and the up-arrow will rotate the block in opposite directions. Alternatively the keys A,W,S and D can be used as arrow keys for the same purpose. When a complete horizontal ring of 15 blocks is occupied by pieces the row will collapse and earn 100 points. If multiple rows are cleared at a time you will earn bonus points. \"A circle may be small, yet it may be as mathematically beautiful and perfect as a large one.\" - Isaac Disraeli Traditional Time Attack Garbage Traditional 1. Empty (0) 2. Empty (0) 3. Empty (0) Time Attack 1. Empty (0) 2. Empty (0) 3. Empty (0) Garbage 1. Empty (59:59) 2. Empty (59:59) 3. Empty (59:59) Skin: Glass Show ghost 0 0:00 You have achieved a high score, please enter your name:"},{"title":"","date":"2020-02-17T08:15:02.160Z","updated":"2020-02-17T08:15:02.160Z","comments":true,"path":"tools/element/index.html","permalink":"brynhild.online/tools/element/index.html","excerpt":"","text":"Elements html, body { height: 100%; } body { background-color: #000000; margin: 0; font-family: Helvetica, sans-serif; ; overflow: hidden; } a { color: #ffffff; } #info { position: absolute; width: 100%; color: #ffffff; padding: 5px; font-family: Monospace; font-size: 13px; font-weight: bold; text-align: center; z-index: 1; } #menu { position: absolute; bottom: 20px; width: 100%; text-align: center; font-family: verdana, Tahoma, Arial, Hei, \"Microsoft Yahei\", SimHei; } .element { width: 120px; height: 160px; box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.5); border: 1px solid rgba(127, 255, 255, 0.25); text-align: center; cursor: default; } .element:hover { box-shadow: 0px 0px 12px rgba(0, 255, 255, 0.75); border: 1px solid rgba(127, 255, 255, 0.75); } .element .number { position: absolute; top: 20px; right: 20px; font-size: 12px; color: rgba(127, 255, 255, 0.75); } .element .symbol { position: absolute; top: 40px; left: 0px; right: 0px; font-size: 60px; font-weight: bold; color: rgba(255, 255, 255, 0.75); text-shadow: 0 0 10px rgba(0, 255, 255, 0.95); } .element .details { position: absolute; bottom: 15px; left: 0px; right: 0px; font-size: 12px; color: rgba(127, 255, 255, 0.75); } button { color: rgba(127, 255, 255, 0.75); background: transparent; outline: 1px solid rgba(127, 255, 255, 0.75); border: 0px; padding: 5px 10px; cursor: pointer; } button:hover { background-color: rgba(0, 255, 255, 0.5); } button:active { color: #000000; background-color: rgba(0, 255, 255, 0.75); } TABLE SPHERE HELIX GRID var table = [ \"H\", \"Hydrogen\", \"1.00794\", 1, 1, \"He\", \"Helium\", \"4.002602\", 18, 1, \"Li\", \"Lithium\", \"#6.941\", 1, 2, \"Be\", \"Beryllium\", \"9.012182\", 2, 2, \"B\", \"Boron\", \"#10.811\", 13, 2, \"C\", \"Carbon\", \"#12.0107\", 14, 2, \"N\", \"Nitrogen\", \"#14.0067\", 15, 2, \"O\", \"Oxygen\", \"#15.9994\", 16, 2, \"F\", \"Fluorine\", \"18.9984032\", 17, 2, \"Ne\", \"Neon\", \"#20.1797\", 18, 2, \"Na\", \"Sodium\", \"22.98976...\", 1, 3, \"Mg\", \"Magnesium\", \"#24.305\", 2, 3, \"Al\", \"Aluminium\", \"26.9815386\", 13, 3, \"Si\", \"Silicon\", \"#28.0855\", 14, 3, \"P\", \"Phosphorus\", \"30.973762\", 15, 3, \"S\", \"Sulfur\", \"#32.065\", 16, 3, \"Cl\", \"Chlorine\", \"#35.453\", 17, 3, \"Ar\", \"Argon\", \"#39.948\", 18, 3, \"K\", \"Potassium\", \"#39.948\", 1, 4, \"Ca\", \"Calcium\", \"#40.078\", 2, 4, \"Sc\", \"Scandium\", \"44.955912\", 3, 4, \"Ti\", \"Titanium\", \"#47.867\", 4, 4, \"V\", \"Vanadium\", \"#50.9415\", 5, 4, \"Cr\", \"Chromium\", \"#51.9961\", 6, 4, \"Mn\", \"Manganese\", \"54.938045\", 7, 4, \"Fe\", \"Iron\", \"#55.845\", 8, 4, \"Co\", \"Cobalt\", \"58.933195\", 9, 4, \"Ni\", \"Nickel\", \"#58.6934\", 10, 4, \"Cu\", \"Copper\", \"#63.546\", 11, 4, \"Zn\", \"Zinc\", \"#65.38\", 12, 4, \"Ga\", \"Gallium\", \"#69.723\", 13, 4, \"Ge\", \"Germanium\", \"#72.63\", 14, 4, \"As\", \"Arsenic\", \"#74.9216\", 15, 4, \"Se\", \"Selenium\", \"#78.96\", 16, 4, \"Br\", \"Bromine\", \"#79.904\", 17, 4, \"Kr\", \"Krypton\", \"#83.798\", 18, 4, \"Rb\", \"Rubidium\", \"#85.4678\", 1, 5, \"Sr\", \"Strontium\", \"#87.62\", 2, 5, \"Y\", \"Yttrium\", \"88.90585\", 3, 5, \"Zr\", \"Zirconium\", \"#91.224\", 4, 5, \"Nb\", \"Niobium\", \"92.90628\", 5, 5, \"Mo\", \"Molybdenum\", \"#95.96\", 6, 5, \"Tc\", \"Technetium\", \"(98)\", 7, 5, \"Ru\", \"Ruthenium\", \"#101.07\", 8, 5, \"Rh\", \"Rhodium\", \"#102.9055\", 9, 5, \"Pd\", \"Palladium\", \"#106.42\", 10, 5, \"Ag\", \"Silver\", \"#107.8682\", 11, 5, \"Cd\", \"Cadmium\", \"#112.411\", 12, 5, \"In\", \"Indium\", \"#114.818\", 13, 5, \"Sn\", \"Tin\", \"#118.71\", 14, 5, \"Sb\", \"Antimony\", \"#121.76\", 15, 5, \"Te\", \"Tellurium\", \"127.6\", 16, 5, \"I\", \"Iodine\", \"126.90447\", 17, 5, \"Xe\", \"Xenon\", \"#131.293\", 18, 5, \"Cs\", \"Caesium\", \"#132.9054\", 1, 6, \"Ba\", \"Barium\", \"#132.9054\", 2, 6, \"La\", \"Lanthanum\", \"138.90547\", 4, 9, \"Ce\", \"Cerium\", \"#140.116\", 5, 9, \"Pr\", \"Praseodymium\", \"140.90765\", 6, 9, \"Nd\", \"Neodymium\", \"#144.242\", 7, 9, \"Pm\", \"Promethium\", \"(145)\", 8, 9, \"Sm\", \"Samarium\", \"#150.36\", 9, 9, \"Eu\", \"Europium\", \"#151.964\", 10, 9, \"Gd\", \"Gadolinium\", \"#157.25\", 11, 9, \"Tb\", \"Terbium\", \"158.92535\", 12, 9, \"Dy\", \"Dysprosium\", \"162.5\", 13, 9, \"Ho\", \"Holmium\", \"164.93032\", 14, 9, \"Er\", \"Erbium\", \"#167.259\", 15, 9, \"Tm\", \"Thulium\", \"168.93421\", 16, 9, \"Yb\", \"Ytterbium\", \"#173.054\", 17, 9, \"Lu\", \"Lutetium\", \"#174.9668\", 18, 9, \"Hf\", \"Hafnium\", \"#178.49\", 4, 6, \"Ta\", \"Tantalum\", \"180.94788\", 5, 6, \"W\", \"Tungsten\", \"#183.84\", 6, 6, \"Re\", \"Rhenium\", \"#186.207\", 7, 6, \"Os\", \"Osmium\", \"#190.23\", 8, 6, \"Ir\", \"Iridium\", \"#192.217\", 9, 6, \"Pt\", \"Platinum\", \"#195.084\", 10, 6, \"Au\", \"Gold\", \"196.966569\", 11, 6, \"Hg\", \"Mercury\", \"#200.59\", 12, 6, \"Tl\", \"Thallium\", \"#204.3833\", 13, 6, \"Pb\", \"Lead\", \"207.2\", 14, 6, \"Bi\", \"Bismuth\", \"#208.9804\", 15, 6, \"Po\", \"Polonium\", \"(209)\", 16, 6, \"At\", \"Astatine\", \"(210)\", 17, 6, \"Rn\", \"Radon\", \"(222)\", 18, 6, \"Fr\", \"Francium\", \"(223)\", 1, 7, \"Ra\", \"Radium\", \"(226)\", 2, 7, \"Ac\", \"Actinium\", \"(227)\", 4, 10, \"Th\", \"Thorium\", \"232.03806\", 5, 10, \"Pa\", \"Protactinium\", \"#231.0588\", 6, 10, \"U\", \"Uranium\", \"238.02891\", 7, 10, \"Np\", \"Neptunium\", \"(237)\", 8, 10, \"Pu\", \"Plutonium\", \"(244)\", 9, 10, \"Am\", \"Americium\", \"(243)\", 10, 10, \"Cm\", \"Curium\", \"(247)\", 11, 10, \"Bk\", \"Berkelium\", \"(247)\", 12, 10, \"Cf\", \"Californium\", \"(251)\", 13, 10, \"Es\", \"Einstenium\", \"(252)\", 14, 10, \"Fm\", \"Fermium\", \"(257)\", 15, 10, \"Md\", \"Mendelevium\", \"(258)\", 16, 10, \"No\", \"Nobelium\", \"(259)\", 17, 10, \"Lr\", \"Lawrencium\", \"(262)\", 18, 10, \"Rf\", \"Rutherfordium\", \"(267)\", 4, 7, \"Db\", \"Dubnium\", \"(268)\", 5, 7, \"Sg\", \"Seaborgium\", \"(271)\", 6, 7, \"Bh\", \"Bohrium\", \"(272)\", 7, 7, \"Hs\", \"Hassium\", \"(270)\", 8, 7, \"Mt\", \"Meitnerium\", \"(276)\", 9, 7, \"Ds\", \"Darmstadium\", \"(281)\", 10, 7, \"Rg\", \"Roentgenium\", \"(280)\", 11, 7, \"Cn\", \"Copernicium\", \"(285)\", 12, 7, \"Uut\", \"Unutrium\", \"(284)\", 13, 7, \"Fl\", \"Flerovium\", \"(289)\", 14, 7, \"Uup\", \"Ununpentium\", \"(288)\", 15, 7, \"Lv\", \"Livermorium\", \"(293)\", 16, 7, \"Uus\", \"Ununseptium\", \"(294)\", 17, 7, \"Uuo\", \"Ununoctium\", \"(294)\", 18, 7 ]; var camera, scene, renderer; var controls; var objects = []; var targets = { table: [], sphere: [], helix: [], grid: [] }; init(); animate(); function init() { camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000); camera.position.z = 3000; scene = new THREE.Scene(); // table for (var i = 0; i < table.length; i += 5) { var element = document.createElement('div'); element.className = 'element'; element.style.backgroundColor = 'rgba(0,127,127,' + (Math.random() * 0.5 + 0.25) + ')'; var number = document.createElement('div'); number.className = 'number'; number.textContent = (i / 5) + 1; element.appendChild(number); var symbol = document.createElement('div'); symbol.className = 'symbol'; symbol.textContent = table[i]; element.appendChild(symbol); var details = document.createElement('div'); details.className = 'details'; details.innerHTML = table[i + 1] + '' + table[i + 2]; element.appendChild(details); var object = new THREE.CSS3DObject(element); object.position.x = Math.random() * 4000 - 2000; object.position.y = Math.random() * 4000 - 2000; object.position.z = Math.random() * 4000 - 2000; scene.add(object); objects.push(object); // var object = new THREE.Object3D(); object.position.x = (table[i + 3] * 140) - 1330; object.position.y = -(table[i + 4] * 180) + 990; targets.table.push(object); } // sphere var vector = new THREE.Vector3(); for (var i = 0, l = objects.length; i < l; i++) { var phi = Math.acos(-1 + (2 * i) / l); var theta = Math.sqrt(l * Math.PI) * phi; var object = new THREE.Object3D(); object.position.x = 800 * Math.cos(theta) * Math.sin(phi); object.position.y = 800 * Math.sin(theta) * Math.sin(phi); object.position.z = 800 * Math.cos(phi); vector.copy(object.position).multiplyScalar(2); object.lookAt(vector); targets.sphere.push(object); } // helix var vector = new THREE.Vector3(); for (var i = 0, l = objects.length; i < l; i++) { var phi = i * 0.175 + Math.PI; var object = new THREE.Object3D(); object.position.x = 900 * Math.sin(phi); object.position.y = -(i * 8) + 450; object.position.z = 900 * Math.cos(phi); vector.x = object.position.x * 2; vector.y = object.position.y; vector.z = object.position.z * 2; object.lookAt(vector); targets.helix.push(object); } // grid for (var i = 0; i < objects.length; i++) { var object = new THREE.Object3D(); object.position.x = ((i % 5) * 400) - 800; object.position.y = (-(Math.floor(i / 5) % 5) * 400) + 800; object.position.z = (Math.floor(i / 25)) * 1000 - 2000; targets.grid.push(object); } // renderer = new THREE.CSS3DRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); renderer.domElement.style.position = 'absolute'; document.getElementById('container').appendChild(renderer.domElement); // controls = new THREE.TrackballControls(camera, renderer.domElement); controls.rotateSpeed = 0.5; controls.minDistance = 500; controls.maxDistance = 6000; controls.addEventListener('change', render); var button = document.getElementById('table'); button.addEventListener('click', function (event) { transform(targets.table, 2000); }, false); var button = document.getElementById('sphere'); button.addEventListener('click', function (event) { transform(targets.sphere, 2000); }, false); var button = document.getElementById('helix'); button.addEventListener('click', function (event) { transform(targets.helix, 2000); }, false); var button = document.getElementById('grid'); button.addEventListener('click', function (event) { transform(targets.grid, 2000); }, false); transform(targets.table, 5000); // window.addEventListener('resize', onWindowResize, false); } function transform(targets, duration) { TWEEN.removeAll(); for (var i = 0; i < objects.length; i++) { var object = objects[i]; var target = targets[i]; new TWEEN.Tween(object.position) .to({ x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration) .easing(TWEEN.Easing.Exponential.InOut) .start(); new TWEEN.Tween(object.rotation) .to({ x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration) .easing(TWEEN.Easing.Exponential.InOut) .start(); } new TWEEN.Tween(this) .to({}, duration * 2) .onUpdate(render) .start(); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); render(); } function animate() { requestAnimationFrame(animate); TWEEN.update(); controls.update(); } function render() { renderer.render(scene, camera); } document.onkeydown = function (e) { var currKey = 0, evt = e || window.event; currKey = evt.keyCode || evt.which || evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2020-03-13T11:39:40.335Z","updated":"2020-03-13T11:39:26.258Z","comments":true,"path":"tools/calc/calc-adv1/index.html","permalink":"brynhild.online/tools/calc/calc-adv1/index.html","excerpt":"","text":"CALCULATOR body { background: linear-gradient(to right, #85D8CE, #085078); } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; display: flex; flex-wrap: wrap; justify-content: center; align-item: center; } .calculator { width: 440px; padding: 20px; border-radius: 5px; margin: 20px auto; font-size: 16px; background-color: #333333; } .input { width: 420px; height: 50px; border-radius: 0px; border: 1px solid black; background-color: #333333; color: #d9d9d9; padding: 0 5px 0 5px; margin: 0 0px 10px 0px; font-size: 30px; } .input:focus, .input:active { border-color: #03a9f4; box-shadow: 0 0 4px #03A9F4; outline: none 0; } .button { margin: 3px; width: 63px; border: 1px solid #0d0d0d; height: 30px; border-radius: 4px; color: #d9d9d9; background-color: #1a1a1a; cursor: pointer; outline: none; } .mode { display: flex; flex-wrap: wrap; justify-content: space-evenly; } .equal-sign { background-color: green; width: 133px; } .toggle-button { border: none; background-color: #333333; cursor: pointer; outline: none; font-size: 1rem; color: #fff; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.35); } p { margin-top: 0; } button::-moz-focus-inner { border-color: transparent; } Show Advanced Mode ⚈ Show Basic Mode ⚆ 7 8 9 *"},{"title":"","date":"2020-03-16T08:07:03.485Z","updated":"2020-03-16T08:07:03.485Z","comments":true,"path":"tools/soduku/index.html","permalink":"brynhild.online/tools/soduku/index.html","excerpt":"","text":"Soduku SUBMIT RESET RETRY var sd = new SD; sd.init(30);"}],"posts":[{"title":"珂学上网 基于VultrVPS的SSR服务器的基本搭建","slug":"vultr_ssr_vpn_buildup","date":"2020-03-01T22:08:23.000Z","updated":"2020-03-12T02:46:59.550Z","comments":true,"path":"vultr_ssr_vpn_buildup/","link":"","permalink":"brynhild.online/vultr_ssr_vpn_buildup/","excerpt":"Vultr SSR VPS 锐速 CentOS VPN GoogleBBR 防火墙","text":"Vultr SSR VPS 锐速 CentOS VPN GoogleBBR 防火墙 购买VPS服务器 我们应该选择国外的VPS(Virtual Private Server)提供商,这里推荐Vultr,性价比较高,最低有$2.5/m的,但其只支持IPv6,所以个人搭建推荐$3.5/m. 目前新账号充值$10可赠送$50,是相当划算的.如果想要通过注册多个账号来减少资费,请务必注意IP地址及GPS定位. VPS服务器的搭建和连接 服务器搭建 在Product页点击加号新建服务器. 选择Cloud Compute. 选择自己熟悉的OS.这里以CentOS为例.CentOS版本建议选6以上,否则也许会出现未知的问题. Vultr提供多个地区的服务器,建议一次性搭建多台之后逐个测试速度,速度较慢的删除即可.服务器按照小时计费,不需要担心资费浪费问题. 扩展功能按需要选择.这里建议勾选Enable IPv6. 服务器搭建完成后可以在Products页面看到. 服务器连接 在服务器页面,我们需要记下服务器的IP 用户名 密码. 我们需要终端用SSH来连接VPS.在Windows操作系统上推荐Xshell.Vultr网站上也提供了命令行,但不推荐使用. 在Xshell上连接 文件-&gt;新建 在连接中填写相关内容. 在用户身份验证中填写用户名和密码. 连接即可. 在终端连接 1ssh your_username@server_IP -p 22 (22是你VPS的SSH端口) 端口可以省略. 相关内容安装 安装SSR 安装wegt 1yum -y install wget 安装SSR 该脚本由 www.qcgzxw.cn 提供. 1wget --no-check-certificate https://freed.ga/github/shadowsocksR.sh; bash shadowsocksR.sh SSR相关配置依需要而定. 搭建成功后会显示IP,端口,密码,协议等,用于填写ShadowsocksR配置信息. 使用锐速为SSR加速 锐速模块依赖于内核,基本原理是对丢包情况进行评估,并重发可能丢的数据包,即锐速多倍发包,在一定程度上能够提高VPN速度. 首先查询系统内核版本 1uname -r 如返回值以2开头,说明服务器为CentOS6,可直接安装锐速. 如返回值以3开头,需要对内核降级. 另: 如果已经安装过Google BBR拥塞控制算法,那么无法安装锐速. CentOS6安装锐速: 1wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install '2.6.32-642.el6.x86_64' 更高版本使用以下命令对内核降级: 1wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/rskernel.sh &amp;&amp; bash rskernel.sh 如图所示,系统为CentOS7,更换内核后系统重启. 重新连接后使用如下指令安装锐速: 1yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install 在过程中图示的三个选项默认即可. 下图为安装运行成功.与锐速相关的指令会在文末给出. 使用Google BBR为SSR加速 这是一个TCP拥塞控制算法.Google BBR的github页面: https://github.com/google/bbr 警告: Google BBR需要升级内核,锐速需要降级内核,二者不可兼得. 卸载原版内核headers. 1yum remove kernel-headers 安装高版本内核headers. 1yum --enablerepo=elrepo-kernel -y install kernel-ml-headers 升级CentOS系统内核. 1yum -y install kernel-ml kernel-ml-devel 升级headers. 1yum -y install kernel-ml-headers 对于CentOS6 1sed -i 's/^default=.*/default=0/g' /boot/grub/grub.conf 对于更高版本 1grub2-set-default 0 使用安装脚本安装Google BBR. 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 这个脚本由 秋水逸冰 提供. 安装后重启服务器,检查BBR是否启动. 1lsmod | grep bbr 返回值有tcp_bbr模块即说明BBR已启动.并不是所有的VPS都会有此返回值,若没有也属正常. SSR多端口配置 使用Vim打开配置文件 1vi /etc/shadowsocks.json 原有内容大致如下: 1234567891011121314151617181920&#123; \"server\": \"0.0.0.0\", \"server_ipv6\": \"::\", \"server_port\": 25565, \"local_address\": \"127.0.0.1\", \"local_port\": 1081, \"password\": \"www.qcgzxw.cn\", \"timeout\": 120, \"udp_timeout\": 60, \"method\": \"aes-256-cfb\", \"protocol\": \"auth_sha1_v4_compatible\", \"protocol_param\": \"\", \"obfs\": \"http_simple_compatible\", \"obfs_param\": \"\", \"dns_ipv6\": false, \"connect_verbose_info\": 1, \"redirect\": \"\", \"fast_open\": false, \"workers\": 1&#125; 删除原有的 server_port 及 password ,新增 port_password ,前面是端口,后面是密码,需要注意格式问题. 示例更改后如下: 12345678910111213141516171819202122232425262728&#123; \"server\": \"0.0.0.0\", \"server_ipv6\": \"::\", \"local_address\": \"127.0.0.1\", \"local_port\": 1081, \"port_password\": &#123; \"1096\":\"hanyuu\", \"1919\":\"senpai\", \"2020\":\"evolution\", \"417\":\"morsunhy\", \"2333\":\"morsun\", \"11451\":\"niconiconi\", \"10960\":\"hanyuu\" &#125;, \"timeout\": 120, \"udp_timeout\": 60, \"method\": \"aes-256-cfb\", \"protocol\": \"auth_sha1_v4_compatible\", \"protocol_param\": \"\", \"obfs\": \"http_simple_compatible\", \"obfs_param\": \"\", \"dns_ipv6\": false, \"connect_verbose_info\": 1, \"redirect\": \"\", \"fast_open\": false, \"workers\": 1&#125; 保存后修改防火墙配置: 1vi /etc/firewalld/zones/public.xml 原有内容大致如下: 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;zone&gt; &lt;short&gt;Public&lt;/short&gt; &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt; &lt;service name=\"dhcpv6-client\"/&gt; &lt;service name=\"ssh\"/&gt; &lt;port protocol=\"tcp\" port=\"25565\"/&gt; &lt;port protocol=\"udp\" port=\"25565\"/&gt;&lt;/zone&gt; 加入新加入的端口,一行tcp,一行udp. 修改后内容大致如下: 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;zone&gt; &lt;short&gt;Public&lt;/short&gt; &lt;service name=\"dhcpv6-client\"/&gt; &lt;service name=\"ssh\"/&gt; &lt;port protocol=\"tcp\" port=\"1096\"/&gt; &lt;port protocol=\"udp\" port=\"1096\"/&gt; &lt;port protocol=\"tcp\" port=\"1919\"/&gt; &lt;port protocol=\"udp\" port=\"1919\"/&gt; &lt;port protocol=\"tcp\" port=\"2020\"/&gt; &lt;port protocol=\"udp\" port=\"2020\"/&gt; &lt;port protocol=\"tcp\" port=\"2333\"/&gt; &lt;port protocol=\"udp\" port=\"2333\"/&gt; &lt;port protocol=\"tcp\" port=\"11451\"/&gt; &lt;port protocol=\"udp\" port=\"11451\"/&gt; &lt;port protocol=\"tcp\" port=\"417\"/&gt; &lt;port protocol=\"udp\" port=\"417\"/&gt; &lt;port protocol=\"tcp\" port=\"10960\"/&gt; &lt;port protocol=\"udp\" port=\"10960\"/&gt;&lt;/zone&gt; 重启SSR. 1/etc/init.d/shadowsocks restart 重启防火墙. 1firewall-cmd --reload 也可以参考下文的指令按照类似流程安装. SSR的使用 下载客户端,配置并连接即可. Shadowsocks: https://shadowsocks.org/ ShadowsocksR: https://github.com/Anankke/SSRR-Windows/ 相关指令扩展 SSR 1234567891011121314151617#启动SSR/etc/init.d/shadowsocks start#停止SSR/etc/init.d/shadowsocks stop#重启SSR/etc/init.d/shadowsocks restart#状态SSR/etc/init.d/shadowsocks status#卸载SSR./shadowsocks-all.sh uninstall#更改配置参数vim /etc/shadowsocks-r/config.json 锐速 1234567891011121314#查看运行状态/appex/bin/serverSpeeder.sh status #启动锐速/appex/bin/serverSpeeder.sh start #停止锐速/appex/bin/serverSpeeder.sh stop #重启锐速/appex/bin/serverSpeeder.sh restart #卸载锐速/appex/bin/serverSpeeder.sh uninstall 防火墙 CentOS7之前版本 iptables 命令 1234567891011121314151617181920#查看已经开放的端口:/etc/init.d/iptables status#开启端口/sbin/iptables -I INPUT -p tcp --dport 端口 -j ACCEPT#保存设置/etc/rc.d/init.d/iptables save#启动防火墙(永久)chkconfig iptables on#停止防火墙(永久)chkconfig iptables off#启动防火墙(暂时,重启失效)service iptables start#关闭防火墙(暂时,重启失效)service iptables stop CentOS7 firewall 命令 1234567891011121314151617181920#启动防火墙systemctl start firewalld#查看防火墙状态systemctl status firewalld#查看已经开放的端口firewall-cmd --list-ports#开启端口(永久)firewall-cmd --zone=public --add-port=端口/tcp --permanent#重启防火墙firewall-cmd --reload#停止防火墙systemctl stop firewalld.service #禁止开机启动systemctl disable firewalld.service 博客内容遵循 Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) 协议. 本文永久链接: https://brynhild.online/vultr_ssr_vpn_buildup/","categories":[{"name":"VPS","slug":"VPS","permalink":"brynhild.online/categories/VPS/"}],"tags":[{"name":"Vultr","slug":"Vultr","permalink":"brynhild.online/tags/Vultr/"},{"name":"SSR","slug":"SSR","permalink":"brynhild.online/tags/SSR/"},{"name":"VPS","slug":"VPS","permalink":"brynhild.online/tags/VPS/"},{"name":"锐速","slug":"锐速","permalink":"brynhild.online/tags/%E9%94%90%E9%80%9F/"},{"name":"BBR","slug":"BBR","permalink":"brynhild.online/tags/BBR/"},{"name":"firewall","slug":"firewall","permalink":"brynhild.online/tags/firewall/"}]},{"title":"扫盲向 利用OBS虚拟摄像头在网课上摸鱼","slug":"obs_internet_class_fishing","date":"2020-03-01T02:08:23.000Z","updated":"2020-03-08T15:24:33.560Z","comments":true,"path":"obs_internet_class_fishing/","link":"","permalink":"brynhild.online/obs_internet_class_fishing/","excerpt":"Windows OBS OBS-VirtualCam Facerig","text":"Windows OBS OBS-VirtualCam Facerig INTRODUCTION 「摸鱼之心，人皆有之，咸者能毋丧耳。」 – Hanyuu ELLIAS 近期不少同学问我网课摸鱼的事,于是有了这个扫盲向博客. REQUIREMENT Open Broadcaster Software OBS-VirtualCam Install and run. USE INPUT 在&quot;来源&quot;中点击加号添加. 作为视频或图像 录一段学习时候的视频或选择一张贴纸. 选择VLC视频源或图像. 点击加号添加文件或路径. 作为视频源 添加视频捕获装置 作为示例,这里选择了Facerig的虚拟摄像头. 我很可爱,请给我钱! 这个模型来自创意工坊,作者为toribako145. 确保其被激活.分辨率选项视情况而定. 将画面充满屏幕. 用上下箭头调整前后位置.确保其出于可视状态. OUTPUT 工具-&gt;虚拟摄像头. 选择目标摄像头(默认即可),水平翻转及保持长宽比例视情况使用. 缓冲帧视性能调整. 启动即可. IN CLASS 选择刚才设置的目标摄像头即可. OTHERS 低配置设备可在设置-&gt;视频中调整分辨率来缓解卡顿. 不使用物理摄像头时将其遮住是个好习惯. 使用Facerig时请留意各方面的版权限制. 摸鱼有风险,使用需谨慎. 请各位&quot;务必&quot;以学业为重! 博客内容遵循 Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) 协议. 本文永久链接: https://brynhild.online/obs_internet_class_fishing/","categories":[{"name":"Trick","slug":"Trick","permalink":"brynhild.online/categories/Trick/"}],"tags":[{"name":"OBS","slug":"OBS","permalink":"brynhild.online/tags/OBS/"}]},{"title":"网易云VIP歌曲NCM格式解密","slug":"ncm_unlock","date":"2020-01-11T08:08:00.000Z","updated":"2020-03-10T23:47:05.355Z","comments":true,"path":"ncm_unlock/","link":"","permalink":"brynhild.online/ncm_unlock/","excerpt":"Windows Android ncmdump 网易云","text":"Windows Android ncmdump 网易云 INTRODUCTION 当发现从网易云音乐下载的VIP音乐成了这副样子 不禁要吐槽: 这真是太( ),太( )了. (中文填空,每空2字) 本文将提供几种NCM格式的解密方案. Web Dev Tools 在官网播放页&quot;偷&quot;缓存,发现了看起来对劲的东西,果断下载+转码,用mp3tag加入封面及歌曲信息,大功告成. 音乐解锁 - By IXarea unlock-music on GitHub 音乐解锁用于移除已购音乐的加密保护.目前支持网易云音乐(ncm) QQ音乐(qmc,mflac,mgg,tkm)以及其他格式,并使用MIT许可协议开放源代码.其使用浏览器对本地文件进行操作,不需要将文件上传. Windows 使用ncmdump或ncmdump-gui.链接指向对应的GitHub仓库. 考虑到GitHub要&quot;夜缒而出&quot;,给出一定版本的下载地址: Release.zip, ncmdump-gui@25Jan2019 大小: 219129 字节 MD5: D90B1FDFCEC35DD3E5BDE912AB35C436 SHA1: B57308A46244823EC44996E62AD45FE5DD32BF26 CRC32: 36B0CD33 ncmdump-gui-lastest.tar.gz, ncmdump-gui@25Jan2019 大小: 72943 字节 MD5: D21AC64AFD09270C0ABFFADD62D50ECF SHA1: 87186625F385E70102DE58E5B8414F99EF1653F6 CRC32: 7A91F3AE ncmdump-windows-amd64.zip, ncmdump@v0.3.0 大小: 3318258 字节 MD5: 9720D5EE3523D377E7F0F7D499665043 SHA1: 9E4F216562B7CED2533A098255FC16794AAC05CE CRC32: 17FC5336 ncmdump-darwin-amd64.zip, ncmdump@v0.3.0 大小: 3461822 字节 MD5: 0CD5CB0A46DE5532CCCD62CD22261E3F SHA1: A8DDFDA576D703E90F7491BCF6D2A907934534A2 CRC32: A2F413A9 ncmdump-0.3.0.tar.gz, ncmdump@v0.3.0 大小: 104499 字节 MD5: 23896D0FEDE39F976003661ACFEF810D SHA1: 85EE97C5CD995FA88616A8523E6862A1836D9D08 CRC32: B142A5B6 Android DroidNCM 安卓版的ncmdump.GitHub页面: https://github.com/bunnyblueair/DroidNCM 下载地址: ncm-release.apk, DroidNCM@v2.1.1 大小: 3054417 字节 MD5: 4F42A5244E817B485C1DE1CA0FE4E8F6 SHA1: B70F7A1401A9DBC858C1E1CF87AF49E9442977D0 CRC32: B3D2E106 DroidNCM-2.1.1.tar.gz, DroidNCM@v2.1.1 大小: 9360077 字节 MD5: 073D92EA36E3EE388E95C0651D3886DA SHA1: F8C50937C661C00D225C00E954F1DA96065A6D38 CRC32: F99D094B 据说这个软件兼容性不是很好,建议下载源码自行编译. 铃声(操作繁琐,不推荐) 在客户端中将歌曲设置为铃声 每次截取60s,直到全部截取 在如图所示的目录中会生成解密后的文件 加.mp3后缀,使用格式工厂拼接即可. 博客内容遵循 Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) 协议. 本文永久链接: https://brynhild.online/ncm_unlock/","categories":[{"name":"Trick","slug":"Trick","permalink":"brynhild.online/categories/Trick/"}],"tags":[{"name":"Trick","slug":"Trick","permalink":"brynhild.online/tags/Trick/"}]},{"title":"buzzer scale define","slug":"buzzer-define","date":"2019-07-07T02:29:42.000Z","updated":"2020-03-02T06:46:42.162Z","comments":true,"path":"buzzer-define/","link":"","permalink":"brynhild.online/buzzer-define/","excerpt":"buzzer scale define","text":"buzzer scale define 123456789101112131415161718192021222324252627282930313233343536#define ddo 262#define dre 294#define dmi 330#define dfa 349#define dso 392#define dla 440#define dsi 494#define do 523#define re 578#define mi 659#define fa 698#define so 784#define la 880#define si 988#define udo 1046#define ure 1175#define umi 1318#define ufa 1480#define uso 1568#define ula 1760#define usi 1976#define sddo 277#define sdre 311#define sdfa 370#define sdso 415#define sdla 466#define sdo 554#define sre 622#define sfa 740#define sso 831#define sla 932#define sudo 1046#define sure 1245#define sufa 1480#define suso 1661#define sula 1865","categories":[{"name":"buzzer","slug":"buzzer","permalink":"brynhild.online/categories/buzzer/"}],"tags":[{"name":"Template","slug":"Template","permalink":"brynhild.online/tags/Template/"},{"name":"buzzer","slug":"buzzer","permalink":"brynhild.online/tags/buzzer/"}]},{"title":"ELLIAS的OI之路","slug":"oi_history","date":"2019-02-02T05:57:07.000Z","updated":"2020-03-11T15:35:32.002Z","comments":true,"path":"oi_history/","link":"","permalink":"brynhild.online/oi_history/","excerpt":"从录取到退役 ELLIAS的OI之路","text":"从录取到退役 ELLIAS的OI之路 2017.7.24 YM录取 2017.12.29 YM1.12新年联欢会OIer合影 2018.1.19 先修调人 YM1.12教室 2018.4.7 窗外风景 非正式参加LN胜选 2018.7.16 YMOI校内集训 2018.7.25 24中集训 2019 NOIp2018省一退役 次の旅を楽しみにしています!","categories":[{"name":"memory","slug":"memory","permalink":"brynhild.online/categories/memory/"}],"tags":[]},{"title":"倍增 洛谷P1967 货车运输","slug":"luogu-P1967-noip2018-day-1","date":"2018-11-09T13:20:49.000Z","updated":"2019-06-10T11:32:06.832Z","comments":true,"path":"luogu-P1967-noip2018-day-1/","link":"","permalink":"brynhild.online/luogu-P1967-noip2018-day-1/","excerpt":"NOIp2018 day-1 RP倍增祈愿 luogu P1967","text":"NOIp2018 day-1 RP倍增祈愿 luogu P1967 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201// luogu-judger-enable-o2#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\")#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;#include &lt;algorithm&gt;using std::sort;#define Re register#define maxn 100001#define maxe 50001#define swap(x,y) ((x)^=(y)^=(x)^=(y))const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = 0; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') c = gc(), m = true; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;inline const int&amp; min (const int&amp; a, const int&amp; b) &#123;return a&lt;b? a:b;&#125;struct node &#123; int fr, to, va;&#125; edge[maxe];inline bool cmp (node a, node b)&#123; return a.va &gt; b.va;&#125;int head[maxn], nxt[maxn], too[maxn], wei[maxn], ecnt;inline void addedge_d (Re int fr, Re int to, Re int va)&#123; nxt[++ ecnt]=head[fr], head[fr]=ecnt, too[ecnt]=to, wei[ecnt]=va; nxt[++ ecnt]=head[to], head[to]=ecnt, too[ecnt]=fr, wei[ecnt]=va;&#125;int fa[maxn];inline int find (register int x)&#123; while (x ^ fa[x]) x = fa[x] = fa[fa[x]]; return x;&#125;inline void Kruskal (Re int n, Re int m)&#123; register int i, j, fr, to, va, ffr, fto; for (i=1; i&lt;=m; ++i) &#123; fr=edge[i].fr, to=edge[i].to, ffr=find(fr), fto=find(to); if (ffr ^ fto) addedge_d (fr, to, edge[i].va), fa[ffr]=fto; &#125;&#125;int fl[maxn];int ex[maxn][18], ew[maxn][18];static void build_tree (Re int x, Re int dep)&#123; register int i, j, to, va; if (!fl[x]) &#123; fl[x] = dep; for (i=head[x]; i; i=nxt[i]) &#123; to=too[i], va=wei[i]; if (!fl[to]) &#123; ex[to][0] = x, ew[to][0] = va; build_tree (to, dep + 1); &#125; &#125; &#125;&#125;inline void build_forest (Re int n)&#123; register int i, j, fr, to, va; for (i=1; i&lt;=n; ++i) if (!fl[i]) &#123; ew[i][0] = 0x3f3f3f3f, ex[i][0] = i; build_tree (i, 1); &#125;&#125;inline void lca_init (Re int n)&#123; register int i, j; for (i=1; i&lt;=17; ++i) &#123; for (j=1; j&lt;=n; ++j) &#123; ex[j][i] = ex[ex[j][i-1]][i-1]; ew[j][i] = min (ew[ex[j][i-1]][i-1], ew[j][i-1]); &#125; &#125;&#125;inline int get_lca (Re int fr, Re int to)&#123; if (find(fr) ^ find(to)) return -1; register int ret=0x3f3f3f3f, i, j; if (fl[fr] &gt; fl[to]) swap (fr, to); for (i=17; i&gt;=0; --i) if (fl[ex[to][i]] &gt;= fl[fr]) ret=min (ret, ew[to][i]), to=ex[to][i]; if (fr == to) return ret; for (i=17; i&gt;=0; --i) &#123; if (ex[fr][i] ^ ex[to][i]) &#123; ret = min (ret, min (ew[to][i], ew[fr][i])); to=ex[to][i], fr=ex[fr][i]; &#125; &#125; ret=min(ret,min(ew[fr][0], ew[to][0])); return ret;&#125;signed main ()&#123; register int i, j, fr, to, va; register int n=read(), m=read(); for (i=1; i&lt;=n; ++i) fa[i] = i; for (i=1; i&lt;=m; ++i) &#123; fr=read(), to=read(), va=read(); edge[i] = &#123;fr, to, va&#125;; &#125; sort (edge+1, edge+m+1, cmp); Kruskal (n, m); build_forest (n); lca_init (n); register int _ = read (); while (_ --) writelen (get_lca(read(), read())); return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"brynhild.online/tags/Template/"},{"name":"倍增","slug":"倍增","permalink":"brynhild.online/tags/%E5%80%8D%E5%A2%9E/"},{"name":"生成树","slug":"生成树","permalink":"brynhild.online/tags/%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"brynhild.online/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"OPTIMIZATION","slug":"OPTIMIZE","date":"2018-11-07T11:17:42.000Z","updated":"2019-06-10T11:32:32.244Z","comments":true,"path":"OPTIMIZE/","link":"","permalink":"brynhild.online/OPTIMIZE/","excerpt":"编译选项 快读 快写 内嵌asm","text":"编译选项 快读 快写 内嵌asm LuoguBlog Fast Read &amp; Write ELLIAS_Old 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class fastio &#123; private: inline char gc() &#123; static char buf[1&lt;&lt;14],*p1=buf,*p2=buf; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;14,stdin),p1==p2)?EOF:*p1++; &#125; public: inline void getint (int &amp;to) &#123; register int x = 0; register char c = gc(); register bool m = 0; while (c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9') &amp;&amp; c != '-') c = gc(); if (c == '-') c = gc(), m = 1; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0', c = gc(); if (m) return -x; else return x; &#125; inline void getuint (int &amp;to) &#123; int x = 0; char c = gc(); while (!isdigit(c)) c = gc(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0', c = gc(); to = x; &#125; inline void getdou (double &amp;to) &#123; double x=0; char ch = getchar (); bool m = 0; while (!isdigit(ch) &amp;&amp; ch != '-') ch = gc (); if (ch == '-') ch = gc(), m = 1; while (isdigit(ch)) x = x * 10 + (ch-48), ch = gc (); if (ch == '.') &#123; double s = 0.1; ch = gc (); while (isdigit(ch)) x = x + (ch-48)*s,s/=10,ch = gc (); &#125; if (m) to = -x; else to = x; &#125; inline void getudou (double &amp;to) &#123; double x=0; char ch = gc (); while (!isdigit(ch)) ch = gc (); while (isdigit(ch)) x = x * 10 + (ch-48), ch = gc (); if (ch == '.') &#123; double s = 0.1; ch = gc (); while (isdigit(ch)) x = x + (ch-48)*s,s/=10,ch = gc (); &#125; to = x; &#125; inline void write (int x) &#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48); &#125;&#125; io; SJB 1234567891011121314151617181920212223242526272829303132333435namespace fastIO &#123; const int str = 1&lt;&lt;20; const char* kiana = \"\\n\"; struct Reader &#123; char buf[str], *s, *t; bool EOF_FLG; Reader():s(buf), t(buf), EOF_FLG(false) &#123;&#125;; inline char gt() &#123;return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);&#125; template &lt;typename T&gt; Reader&amp;operator &gt;&gt; (T&amp;x) &#123; if (EOF_FLG)return *this; register char c=0,d; while (c != EOF &amp;&amp; (!isdigit(c)))d=c,c=gt(); if(c == EOF) &#123;EOF_FLG=true; return *this;&#125; else x = 0; while(isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + c - '0', c = gt(); if (d == '-') x =- x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123;fwrite(buf,1,s-buf,stdout);&#125; inline void pt(char c) &#123;(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);&#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x) return pt('0'),*this; if(x&lt;0) pt('-'), x = -x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123;while(*s)pt(*s++);return *this;&#125; &#125; cout;&#125; ELLIAS_New 1234567891011121314151617181920const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = 0; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') c = gc(), m = true; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125; SWITCH OLD (2017) 123456789#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\") OLD(2018.3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma GCC optimize (2)#pragma G++ optimize (2)#pragma GCC optimize (3)#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\")#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-fwhole-program\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-fstrict-overflow\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-skip-blocks\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"-funsafe-loop-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\") NOIp2018 1234567891011121314151617181920212223242526272829303132333435363738394041#pragma GCC optimize (2)#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\") 内嵌asm优化 a * b % mo 12345inline long long mul_mod (register long long a,register long long b,register long long mo) &#123; register long long ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\" : \"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo)); return ret;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"brynhild.online/tags/Template/"}]},{"title":"Nescafé17 守卫者的挑战","slug":"Nescafe17-Defenders'-Challenge","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:32:24.468Z","comments":true,"path":"Nescafe17-Defenders'-Challenge/","link":"","permalink":"brynhild.online/Nescafe17-Defenders'-Challenge/","excerpt":"Nescafé17 守卫者的挑战","text":"Nescafé17 守卫者的挑战 守卫者的挑战 [Description] 打开了黑魔法师Vani的大门,队员们在迷宫般的路上漫无目的地搜寻着关押applepi的监狱的所在地.突然,眼前一道亮光闪过.“我,Nizem,是黑魔法圣殿的守卫者.如果你能通过我的挑战,那么你可以带走黑魔法圣殿的地图……”瞬间,队员们被传送到了一个擂台上,最初身边有一个容量为K的包包. 擂台赛一共有项挑战,各项挑战依次进行.第项挑战有一个属性ai,如果ai≥0,表示这次挑战成功后可以再获得一个容量为ai的包包；如果ai = -1,则表示这次挑战成功后可以得到一个大小为 1 的地图残片.地图残片必须装在包包里才能带出擂台,包包没有必要全部装满,但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑,只需要完成所有N项挑战后背包容量足够容纳地图残片即可）,才能拼出完整的地图.并且他们至少要挑战成功L次才能离开擂台. 队员们一筹莫展之时,善良的守卫者Nizem帮忙预估出了每项挑战成功的概率,其中第i项挑战成功的概率为pi%.现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率. [Data Size] 对于 100% 的数据,保证 $ 0≤K≤2000$ , $ 0≤N≤200$ , $-1≤ai≤1000$ , $0≤L≤N$ , $0≤pi≤100$ . [Solution] 刚看到此题时,我被那个概率吓得半死.但看了数据范围,此题就是一道很简单的水题了. 对于可以赢l把以上并且背包不会溢出的概率 $P_0$ ,通过枚举结束时的背包容量和赢的次数快速求出: $$ P_0=\\sum_{i=l}{n}\\sum_{j=0}{K}P_{i, j} $$ 而 $P_{i, j}$ 可以通过刷表法 $O(n2K)≈8*107$ 地求出: 定义状态 $dp[i][j][k]$ 代表达到第$i$场胜$j$场背包容量为$k$时的概率,转移方程很显然为本次成功的概率和本次失败的概率之和: 123dp[i][j][k] += dp[i-1][j][k] * (1 - dat[i].dat);if ((tmp = min (K + dat[i].opt, n)) &lt; 0) continue;dp[i][j+1][tmp] += dp[i-1][j][k] * dat[i].dat; 这个时间复杂度看起来很悬,未免会有稍作优化的想法.本题K的范围2000,但是真的需要2000吗?共有N项挑战,对于每一项挑战最多可以获得一块地图残片,所以背包实际的最大容量就是N次挑战中所有类型-1的数量,极限情况下是n,这样复杂度就会降到 $O(n^3)$, 较为稳妥. [Code] 考场代码,写得略丑,请谅解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#pragma G++ optimize (3)#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;inline double getdou ()&#123; register double x=0; register char c = gc (); while (c &lt; '0' || c &gt; '9') c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = x * 10 + (c^'0'), c = gc(); if (c == '.') &#123; register double s = 0.1, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = x + (c-'0')*s, s/=10, c = gc (); &#125; return x;&#125;inline const int&amp; min (const int&amp; a, const int&amp; b)&#123;return a&lt;b? a:b;&#125;#define Re registerstruct node &#123; int opt; double dat;&#125; dat[201];inline bool cmp (node a, node b) &#123;return a.opt &gt; b.opt;&#125;double dp[201][201][201];signed main ()&#123; freopen (\"guard.in\", \"r\", stdin); freopen (\"guard.out\",\"w\",stdout); register int n = read (), l = read (), k = read (), tmp; for (Re int i = 1; i &lt;= n; ++ i) dat[i].dat = getdou()/100; for (Re int i = 1; i &lt;= n; ++ i) dat[i].opt = read (); std::sort (dat + 1, dat + n + 1, cmp); dp[0][0][min(n, k)] = 1.0; for (Re int i = 1; i &lt;= n; ++ i) &#123; for (Re int j = 0; j &lt;= i; ++ j) &#123; for (Re int K = 0; K &lt;= n; ++ K) &#123; dp[i][j][K] += dp[i-1][j][K] * (1 - dat[i].dat); if ((tmp = min (K + dat[i].opt, n)) &lt; 0) continue; dp[i][j+1][tmp] += dp[i-1][j][K] * dat[i].dat; &#125; &#125; &#125; register double ans = 0.0; for (Re int i = l; i &lt;= n; ++ i) for (Re int j = 0; j &lt;= n; ++ j) ans += dp[n][i][j]; printf (\"%.6lf\", ans); fclose (stdin), fclose (stdout); return 0;&#125; Cena评测$0.03s$,效率还是可以的.","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"contest","slug":"contest","permalink":"brynhild.online/tags/contest/"},{"name":"DP","slug":"DP","permalink":"brynhild.online/tags/DP/"}]},{"title":"SP1716 GSS3 - Can you answer these queries III","slug":"GSS3","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:31:22.545Z","comments":true,"path":"GSS3/","link":"","permalink":"brynhild.online/GSS3/","excerpt":"GSS3 - Can you answer these queries III","text":"GSS3 - Can you answer these queries III Luogu Vjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define rint register intint n, m, x, y, in, opt;struct node &#123; int sum, lmax, rmax, dat, l, r;&#125; tr[200001];namespace FastIO &#123; const int str=1&lt;&lt;20; const char* endl=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;(c&lt;'0'||c&gt;'9'))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;inline const int&amp; max(const int&amp; x,const int&amp; y) &#123; return x&gt;y?x:y;&#125;inline void update (int rt) &#123; tr[rt].sum =tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum; tr[rt].lmax= max (tr[rt&lt;&lt;1].lmax, tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].lmax); tr[rt].rmax= max (tr[rt&lt;&lt;1|1].rmax, tr[rt&lt;&lt;1|1].sum + tr[rt&lt;&lt;1].rmax); tr[rt].dat = max (max(tr[rt&lt;&lt;1].dat, tr[rt&lt;&lt;1|1].dat), tr[rt&lt;&lt;1].rmax + tr[rt&lt;&lt;1|1].lmax);&#125;inline void build (int rt,int l,int r) &#123; tr[rt].l = l, tr[rt].r = r; if(l==r) &#123; FastIO::cin&gt;&gt;in; tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = in; return; &#125; int mid = (l+r)&gt;&gt;1; build (lson); build (rson); update (rt);&#125;inline node query (int rt, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; int mid = (l+r)&gt;&gt;1; if (ql &gt; mid) return query (rson, ql, qr); if (qr &lt;= mid) return query (lson, ql, qr); else &#123; node ans,a,b; a = query (lson,ql,qr); b = query (rson,ql,qr); ans.sum = a.sum + b.sum; ans.dat = max (a.dat, a.rmax + b.lmax), ans.dat = max (ans.dat, b.dat); ans.lmax= max (a.lmax, a.sum + b.lmax); ans.rmax= max (b.rmax, b.sum + a.rmax); return ans; &#125;&#125;inline void work (int rt, int to, int val)&#123; if (tr[rt].l == tr[rt].r) &#123; tr[rt].sum = tr[rt].lmax = tr[rt].rmax = tr[rt].dat = val; return; &#125; register int mid = (tr[rt].l + tr[rt].r) &gt;&gt; 1; if (to &lt;= mid) work (rt&lt;&lt;1, to, val); else work (rt&lt;&lt;1|1, to, val); update(rt);&#125;using namespace FastIO;int main ()&#123; //freopen (\"nico.in\",\"r\",stdin); cin &gt;&gt; n; build (1, 1, n); cin &gt;&gt; m; while (m --) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (opt) cout &lt;&lt; query (1, 1, n, x, y).dat &lt;&lt; endl; else work (1,x,y); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"brynhild.online/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"brynhild.online/tags/segment-tree/"}]},{"title":"SP2916 GSS5 - Can you answer these queries V","slug":"GSS5","date":"2018-11-02T02:08:23.000Z","updated":"2020-02-13T14:46:22.452Z","comments":true,"path":"GSS5/","link":"","permalink":"brynhild.online/GSS5/","excerpt":"GSS4 - Can you answer these queries V","text":"GSS4 - Can you answer these queries V Luogu Vjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#pragma GCC optimize (2)#pragma G++ optimize (2)#pragma GCC optimize (3)#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\")#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS], *p1 = buf, *p2 = buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = 0; while (c &lt; '0' || c &gt; '9') &#123;if (c == '-') m = true; c = gc();&#125; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x)&#123; if (x &lt; 0ll) putchar('-'), x = -x; write (x), putchar ('\\n');&#125;#define Re register#define maxn 10001#define dmax 40001#define swap(x,y) ((y)^=(x)^=(y)^=(x)) struct node &#123; int l, r; long long sum, lmax, rmax, dat;&#125; tr[dmax], null;inline const long long&amp; max (const long long&amp; x,const long long&amp; y) &#123;return x&gt;y? x:y;&#125;inline void update (int rt)&#123; register int lson = rt&lt;&lt;1, rson = rt&lt;&lt;1|1; tr[rt].sum = tr[lson].sum + tr[rson].sum; tr[rt].lmax= max (tr[lson].lmax, tr[lson].sum + tr[rson].lmax); tr[rt].rmax= max (tr[rson].rmax, tr[rson].sum + tr[lson].rmax); tr[rt].dat = max (max(tr[lson].dat, tr[rson].dat), tr[lson].rmax + tr[rson].lmax);&#125;static void build (int rt, int l, int r) &#123; tr[rt].l = l, tr[rt].r = r; if (l == r) &#123;tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = read (); return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid + 1, r); update (rt);&#125;static node query (int rt, int ql, int qr) &#123; register int l = tr[rt].l, r = tr[rt].r; if (ql &gt; qr) return null; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; register int mid = (l + r) &gt;&gt; 1; if (ql &gt; mid) return query (rt&lt;&lt;1|1,ql,qr); if (qr &lt;= mid) return query (rt&lt;&lt;1, ql, qr); else &#123; register node ret, a, b; a = query (rt&lt;&lt;1, ql, qr), b = query (rt&lt;&lt;1|1, ql, qr); ret.sum = a.sum + b.sum; ret.dat = max (a.dat, a.rmax + b.lmax), ret.dat = max (ret.dat, b.dat); ret.lmax= max (a.lmax, a.sum + b.lmax), ret.rmax= max (b.rmax, b.sum + a.rmax); return ret; &#125;&#125;static void modify (int rt, int to, long long val)&#123; if (tr[rt].l == tr[rt].r) &#123;tr[rt].sum = tr[rt].lmax = tr[rt].rmax = tr[rt].dat = val; return;&#125; register int mid = (tr[rt].l + tr[rt].r) &gt;&gt; 1; if (to &lt;= mid) modify (rt&lt;&lt;1, to, val); else modify (rt&lt;&lt;1|1, to, val); update(rt);&#125;int main() &#123; register int _ = read (); register int x1, y1, x2, y2; register int n, m; register node a, b, c; register long long tmp; register char opt; while (_ --) &#123; n = read ();//, m = read (); build (1, 1, n); m = read (); while (m --) &#123; //opt = 'z'; //while ((opt ^ 'C') &amp;&amp; (opt ^ 'Q')) opt = gc(); //if (opt ^ 'C') &#123; x1 = read (), y1 = read (), x2 = read (), y2 = read (); if (y1&lt;x1) swap(x1,y1); if (y2&lt;x2) swap(x2,y2); if (x1&gt;y2) swap(x1,x2), swap(y1,y2); if (y1 &lt; x2) &#123; writelen (max(query(1,x1,y1-1).rmax, 0) + query(1,y1,x2).sum + max(query(1,x2+1,y2).lmax, 0)); &#125; else &#123; a = query (1, x2, y1), b = query(1,x1,x2-1), c = query(1,y1+1,y2); tmp = a.dat; tmp = max (tmp, a.lmax + b.rmax); tmp = max (tmp, c.lmax + a.rmax); tmp = max (tmp, a.sum + max(0, b.rmax) + max(0, c.lmax)); writelen (tmp); &#125; &#125; //else &#123;x1 = read (), tmp = read (); modify (1, x1, tmp);&#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"brynhild.online/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"brynhild.online/tags/segment-tree/"}]},{"title":"SP2713 GSS4 - Can you answer these queries IV","slug":"GSS4","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:31:32.924Z","comments":true,"path":"GSS4/","link":"","permalink":"brynhild.online/GSS4/","excerpt":"GSS4 - Can you answer these queries IV","text":"GSS4 - Can you answer these queries IV Luogu Vjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#define root 1,1,n#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define swap(x,y) y^=x^=y^=x#define maxn 100001 #define dmax 400001#define rint register int#define ll long longnamespace fastIO &#123; const int str=1&lt;&lt;20; const char* endll=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; #define gt() getchar() template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;!isdigit(c))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; #define pt(c) putchar(c) template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;using namespace fastIO;struct TreeNode &#123; int l, r; long long sum, mxx;&#125; dat[dmax];long long in;inline const long long&amp; max (const long long&amp; x,const long long&amp; y) &#123;return x&gt;y? x:y;&#125;inline void update (int rt)&#123; dat[rt].sum = dat[rt&lt;&lt;1].sum + dat[rt&lt;&lt;1|1].sum; dat[rt].mxx = max (dat[rt&lt;&lt;1].mxx, dat[rt&lt;&lt;1|1].mxx);&#125;inline void build (int rt, int l, int r)&#123; dat[rt].l = l, dat[rt].r = r; if (l == r) &#123; fastIO::cin &gt;&gt; in; dat[rt].sum = dat[rt].mxx = in; return; &#125; register int mid = (l + r) &gt;&gt; 1; build (lson); build (rson); update (rt);&#125;inline long long query (int rt, int l, int r)&#123; register int L = dat[rt].l, R = dat[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return dat[rt].sum; register int mid = (L + R) &gt;&gt; 1; register long long ret = 0ll; if (l &lt;=mid) ret = query (rt&lt;&lt;1, l, r); if (mid &lt; r) ret += query (rt&lt;&lt;1|1,l,r); return ret;&#125;inline void change (int rt, int l, int r)&#123; register int L = dat[rt].l, R = dat[rt].r; if (L == R) &#123; //cout&lt;&lt;dat[rt].sum&lt;&lt;\" -&gt; \"; dat[rt].sum = sqrt (dat[rt].sum), dat[rt].mxx = sqrt (dat[rt].mxx); //cout&lt;&lt;dat[rt].sum&lt;&lt;endll; return; &#125; register int mid = (L + R) &gt;&gt; 1; if (l&lt;=mid &amp;&amp; dat[rt&lt;&lt;1].mxx &gt;1) change (rt&lt;&lt;1, l, r); if (mid&lt; r &amp;&amp; dat[rt&lt;&lt;1|1].mxx&gt;1) change (rt&lt;&lt;1|1,l,r); update (rt);&#125;//using namespace fastIO;inline void Write (const int&amp; x, const int&amp; y) &#123;cout &lt;&lt; query(1, x, y) &lt;&lt; endll;&#125;inline void Change (const int&amp; x, const int&amp; y) &#123;change (1, x, y);&#125;int main ()&#123; register int _ = 0, n; while (scanf (\"%d\", &amp;n) != EOF) &#123; fastIO::cout &lt;&lt; \"Case #\" &lt;&lt; ++ _ &lt;&lt; \":\" &lt;&lt; endll; build (root); register int m, x, y, ret; register bool opt; fastIO::cin &gt;&gt; m; while (m --) &#123; fastIO::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (x &gt; y) swap (x, y); opt? Write(x, y):Change (x, y); &#125; putchar ('\\n'); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"brynhild.online/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"brynhild.online/tags/segment-tree/"}]},{"title":"GSS1 - Can you answer these queries I","slug":"GSS1","date":"2018-11-02T02:08:23.000Z","updated":"2019-06-10T11:31:26.799Z","comments":true,"path":"GSS1/","link":"","permalink":"brynhild.online/GSS1/","excerpt":"GSS1 - Can you answer these queries I","text":"GSS1 - Can you answer these queries I Luogu SP1043 Vjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define rint register intint n, m, x, y, in;struct node &#123; int sum, lmax, rmax, dat;&#125; tr[200001];namespace FastIO &#123; const int str=1&lt;&lt;20; const char* endl=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;(c&lt;'0'||c&gt;'9'))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;inline const int&amp; max(const int&amp; x,const int&amp; y) &#123; return x&gt;y?x:y;&#125;inline void update (int rt) &#123; tr[rt].sum =tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum; tr[rt].lmax= max (tr[rt&lt;&lt;1].lmax, tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].lmax); tr[rt].rmax= max (tr[rt&lt;&lt;1|1].rmax, tr[rt&lt;&lt;1|1].sum + tr[rt&lt;&lt;1].rmax); tr[rt].dat = max (max(tr[rt&lt;&lt;1].dat, tr[rt&lt;&lt;1|1].dat), tr[rt&lt;&lt;1].rmax + tr[rt&lt;&lt;1|1].lmax);&#125;inline void build (int rt,int l,int r) &#123; if(l==r) &#123; FastIO::cin&gt;&gt;in; tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = in; return; &#125; int mid = (l+r)&gt;&gt;1; build (lson); build (rson); update (rt);&#125;inline node query (int rt, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; int mid = (l+r)&gt;&gt;1; if (ql &gt; mid) return query (rson, ql, qr); if (qr &lt;= mid) return query (lson, ql, qr); else &#123; node ans,a,b; a = query (lson,ql,qr); b = query (rson,ql,qr); ans.sum = a.sum + b.sum; ans.dat = max (a.dat, a.rmax + b.lmax), ans.dat = max (ans.dat, b.dat); ans.lmax= max (a.lmax, a.sum + b.lmax); ans.rmax= max (b.rmax, b.sum + a.rmax); return ans; &#125;&#125;using namespace FastIO;int main() &#123; //freopen (\"nico.in\",\"r\",stdin); FastIO::cin&gt;&gt;n; build (1, 1, n); FastIO::cin&gt;&gt;m; while (m --) &#123; FastIO::cin&gt;&gt;x&gt;&gt;y; FastIO::cout&lt;&lt;query(1, 1, n, x, y).dat&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"GSS","slug":"GSS","permalink":"brynhild.online/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"brynhild.online/tags/segment-tree/"}]},{"title":"STL 洛谷P3369 普通平衡树","slug":"lg-P3369-STL","date":"2018-10-30T08:31:14.000Z","updated":"2019-06-10T11:32:01.705Z","comments":true,"path":"lg-P3369-STL/","link":"","permalink":"brynhild.online/lg-P3369-STL/","excerpt":"luogu P3369 普通平衡树","text":"luogu P3369 普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; c ^ '-') c = gc(); if (c == '-') m = true, c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0) x=-x, putchar('-');write (x);putchar ('\\n');&#125;vector &lt;int&gt; eli;signed main ()&#123; register int n = read (), x, opt; while (n --) &#123; opt = read (), x = read (); if (opt == 1) eli.insert(upper_bound(eli.begin(), eli.end(), x), x); else if (opt == 2) eli.erase(lower_bound(eli.begin(), eli.end(), x)); else if (opt == 3) writelen(lower_bound(eli.begin(), eli.end(), x)-eli.begin()+1); else if (opt == 4) writelen(eli[x - 1]); else if (opt == 5) writelen(*--lower_bound(eli.begin(), eli.end(), x)); else if (opt == 6) writelen(*upper_bound(eli.begin(), eli.end(), x)); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"brynhild.online/tags/Template/"},{"name":"STL","slug":"STL","permalink":"brynhild.online/tags/STL/"}]},{"title":"洛谷 线段树模板","slug":"luogu-segment-tree","date":"2018-06-08T11:29:26.000Z","updated":"2019-06-10T11:32:20.647Z","comments":true,"path":"luogu-segment-tree/","link":"","permalink":"brynhild.online/luogu-segment-tree/","excerpt":"洛谷 线段树1 线段树2 模板","text":"洛谷 线段树1 线段树2 模板 P3372 [模板] 线段树 1 Luogu P3372 线段树加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma GCC optimize (2)//...略#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;#define Re register#define maxn 100001#define dmax 400001typedef long long ll;#define swap(x,y) ((x)^=(y)^=(x)^=(y))struct SMT &#123; int l, r; long long sum, tag;&#125; tr[dmax];inline void update (Re int rt) &#123; tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;&#125;static void build (Re int rt, Re int l, Re int r)&#123; tr[rt].l = l, tr[rt].r = r; if (l == r) &#123;tr[rt].sum = read(); return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid+1, r); update (rt);&#125;inline void pushdown (Re int rt)&#123; if (rt &gt; 200000 || !tr[rt].tag) return; register int ls = rt&lt;&lt;1, rs = rt&lt;&lt;1|1; tr[ls].tag += tr[rt].tag, tr[rs].tag += tr[rt].tag; tr[ls].sum += tr[rt].tag * (tr[ls].r - tr[ls].l + 1), tr[rs].sum += tr[rt].tag * (tr[rs].r - tr[rs].l + 1); tr[rt].tag = 0;&#125;static void modify (Re int rt, Re int l, Re int r, Re ll val)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; tr[rt].sum += val * (R - L + 1), tr[rt].tag += val; return; &#125; register int mid = (L + R) &gt;&gt; 1; pushdown (rt); if (l &lt;= mid) modify (rt&lt;&lt;1, l, r, val); if (r &gt; mid) modify (rt&lt;&lt;1|1,l,r, val); update (rt);&#125;static long long query (Re int rt, Re int l, Re int r)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].sum; pushdown (rt); register int mid = (L+R)&gt;&gt;1; register long long ret = 0; if (l &lt;= mid) ret = query (rt&lt;&lt;1, l, r); if (r &gt; mid) ret += query (rt&lt;&lt;1|1,l,r); return ret;&#125;signed main ()&#123; register int n=read(), m=read(); register int opt, x, y; register long long z; build (1, 1, n); while (m --) &#123; opt=read(), x=read(), y=read(); if (x &gt; y) swap (x, y); if (opt == 2) writelen (query (1, x, y)); else z = read (), modify (1, x, y, z); &#125; return 0;&#125; P3373 [模板]线段树 2 Luogu P3372 加 乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#pragma GCC optimize (2)//..略#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;inline long long mul_mod (register long long a,register long long b,register long long mo) &#123; register long long ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\" : \"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo)); return ret;&#125;#define Re register#define maxn 100001#define dmax 400001typedef long long ll;#define swap(x,y) ((x)^=(y)^=(x)^=(y))#define mod(x) (((x)%modn+modn)%modn)long long modn;struct SMT &#123; int l, r; long long sum, add, mul;&#125; tr[dmax];inline void update (Re int rt) &#123; tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;&#125;static void build (Re int rt, Re int l, Re int r)&#123; tr[rt] = &#123;l, r, 0ll, 0ll, 1ll&#125;; if (l == r) &#123;tr[rt].sum = read()%modn; return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid+1, r); update (rt);&#125;inline void pushdown (Re int rt)&#123; if (rt &gt; 200000 || (!tr[rt].add &amp;&amp; tr[rt].mul == 1ll)) return; register int ls = rt &lt;&lt; 1, rs = rt &lt;&lt; 1 | 1; tr[ls].mul = mul_mod (tr[ls].mul, tr[rt].mul, modn); tr[rs].mul = mul_mod (tr[rs].mul, tr[rt].mul, modn); tr[ls].add = mod (mul_mod (tr[ls].add , tr[rt].mul, modn) + tr[rt].add); tr[rs].add = mod (mul_mod (tr[rs].add, tr[rt].mul, modn) + tr[rt].add); tr[ls].sum = mod (mul_mod (tr[ls].sum, tr[rt].mul, modn) + mul_mod (tr[rt].add, (tr[ls].r - tr[ls].l + 1), modn)); tr[rs].sum = mod (mul_mod (tr[rs].sum, tr[rt].mul, modn) + mul_mod (tr[rt].add, (tr[rs].r - tr[rs].l + 1), modn)); tr[rt].add = 0ll, tr[rt].mul = 1ll;&#125;// opt==1: mul opt==2: addstatic void modify (Re int rt, Re int l, Re int r, Re ll val, Re int opt)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; if (opt == 2) &#123; tr[rt].add = mod (tr[rt].add + val),\\ tr[rt].sum = mod (tr[rt].sum + mul_mod (val, (R - L + 1), modn)); return; &#125; else &#123; tr[rt].mul = mul_mod (tr[rt].mul, val, modn),\\ tr[rt].sum = mul_mod (tr[rt].sum, val, modn),\\ tr[rt].add = mul_mod (tr[rt].add, val, modn); return; &#125; &#125; pushdown (rt); register int mid = (L + R) &gt;&gt; 1; if (l &lt;= mid) modify (rt&lt;&lt;1, l, r, val, opt); if (r &gt; mid) modify (rt&lt;&lt;1|1,l,r, val, opt); update (rt);&#125;static long long query (Re int rt, Re int l, Re int r)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].sum; pushdown (rt); register int mid = (L+R)&gt;&gt;1; register long long ret = 0; if (l &lt;= mid) ret = query (rt&lt;&lt;1, l, r); if (r &gt; mid) ret += query (rt&lt;&lt;1|1,l,r); return ret % modn;&#125;signed main ()&#123; register int n=read(), m=read(); modn=read(); register int opt, x, y; register long long z; build (1, 1, n); while (m --) &#123; opt=read(), x=read(), y=read(); if (x &gt; y) swap (x, y); if (opt == 3) writelen (query (1,x,y)); else z=read()%modn,modify(1,x,y,z,opt); &#125; return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"brynhild.online/tags/segment-tree/"},{"name":"Template","slug":"Template","permalink":"brynhild.online/tags/Template/"}]},{"title":"最短路模板","slug":"shortest-path","date":"2017-12-05T06:47:00.000Z","updated":"2019-06-10T11:32:38.796Z","comments":true,"path":"shortest-path/","link":"","permalink":"brynhild.online/shortest-path/","excerpt":"SPFA 堆优化迪杰斯特拉 C++模板","text":"SPFA 堆优化迪杰斯特拉 C++模板 SPFA Luogu P3371 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma G++ optimize (3)#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; c ^ '-') c = gc(); if (c == '-') m = true, c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;inline const int&amp; min (const int&amp; a, const int&amp; b) &#123;return a&lt;b? a:b;&#125;#define Re register#define maxn 10001#define maxm 500001int head[maxn], nxt[maxm], too[maxm], ecnt;long long wei[maxm], dis[maxn];int que[maxm*100 + 100];bool vis[maxn];signed main ()&#123; register int n = read (), m = read (), sta = read (); for (Re int i = 1; i &lt;= n; ++ i) dis[i] = 2147483647; register int fr, to, va; while (m --) &#123; fr = read (), to = read (), va = read (); nxt[++ ecnt] = head[fr], head[fr] = ecnt, too[ecnt] = to, wei[ecnt] = va; &#125; dis[sta] = 0; register int hd = 0, tl = 1; que[tl] = sta; while (hd &lt; tl) &#123; fr = que[++ hd], vis[fr] = false; for (Re int i = head[fr]; i; i = nxt[i]) &#123; to = too[i], va = wei[i]; if (dis[to] &gt; dis[fr] + va) &#123; dis[to] = dis[fr] + va; if (!vis[to]) vis[to] = true, que[++ tl] = to; &#125; &#125; &#125; for (Re int i = 1; i &lt;= n; ++ i) &#123; if (dis[i]&lt;0) dis[i] = -dis[i], putchar ('-'); write (dis[i]), putchar (' '); &#125; return 0;&#125; 堆优化迪杰斯特拉 Luogu P4779 OLD (2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"avx\",\"sse2\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;#define maxn 100001#define maxm 200001#define inff 2147483647inline int read () &#123; int x = 0; char c = getchar(); bool m = false; while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') c = getchar(), m = true; while (isdigit(c)) x = x * 10 + c - 48, c = getchar(); if (m) return -x; else return x;&#125;inline void fastwrite (int x) &#123; if(x &lt; 0) x = -x, putchar('-'); if(x &gt; 9) fastwrite(x / 10); putchar(x%10 + '0');&#125;inline void fastwritespace (int x) &#123; fastwrite(x); putchar(' ');&#125;struct node &#123; int val, name;&#125;;struct cmp &#123; inline bool operator() (const node&amp; aa, const node&amp; bb) &#123; return aa.val &gt; bb.val; &#125;&#125;;int n, m, s, fro, to, w;int dis[maxn];bool visit[maxn];vector &lt;pair &lt;int, int&gt; &gt; data[maxn];__gnu_pbds::priority_queue &lt;node, cmp, pairing_heap_tag&gt; nico;int main () &#123; n = read (), m = read (), s = read (); for (int i = 1; i &lt;= m; i ++) &#123; fro = read (), to = read (), w = read (); data[fro].push_back (make_pair (to, w)); &#125; for (int i = 1; i &lt;= n; i ++) dis[i] = inff; dis[s] = 0; nico.push ((node) &#123; 0, s &#125;); while (!nico.empty ()) &#123; fro = nico.top ().name; nico.pop (); if (visit[fro]) continue; visit[fro] = true; for (int i = 0; i &lt; data[fro].size (); i ++) &#123; to = data[fro][i].first; w = data[fro][i].second; if (!visit[to] &amp;&amp; dis[fro] + w &lt; dis[to]) &#123; dis[to] = dis[fro] + w; nico.push ((node) &#123; dis[to], to &#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i ++) fastwritespace (dis[i]); return 0;&#125; NEW(2018/11/5) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#pragma G++ optimize (3)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using std::priority_queue;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void nwrite (int x) &#123;write (x); putchar (' ');&#125;#define maxn 100001#define maxm 200001#define Re registerstruct node &#123; int id, val; friend bool operator &lt; (node a, node b) &#123; return a.val &gt; b.val; &#125;&#125;;priority_queue &lt;node&gt; que;int head[maxn], wei[maxm], too[maxm], nxt[maxm], ecnt;bool vis[maxn];int dis[maxn];signed main ()&#123; register int n = read (), m = read (), sta = read (); register int fr, to, va; while (m --) &#123; fr = read (), nxt[++ ecnt] = head[fr],\\ head[fr] = ecnt, too[ecnt] = read (), wei[ecnt] = read (); &#125; memset (dis, 0x3f3f3f3f, sizeof dis); dis[sta] = 0; que.push (&#123;sta, 0&#125;); while (!que.empty ()) &#123; fr = que.top ().id, que.pop (); if (!vis[fr]) &#123; vis[fr] = true; for (Re int i = head[fr]; i; i = nxt[i]) &#123; to = too[i], va = wei[i]; if (dis[fr] + va &lt; dis[to]) &#123; dis[to] = dis[fr] + va; que.push (&#123;to, dis[to]&#125;); &#125; &#125; &#125; &#125; for (Re int i = 1; i &lt;= n; ++ i) nwrite (dis[i]); return 0;&#125;","categories":[{"name":"Olympiad in Informatics","slug":"Olympiad-in-Informatics","permalink":"brynhild.online/categories/Olympiad-in-Informatics/"}],"tags":[{"name":"Template","slug":"Template","permalink":"brynhild.online/tags/Template/"},{"name":"最短路","slug":"最短路","permalink":"brynhild.online/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"HEXO博客的基本搭建","slug":"hexo-buildup","date":"2017-11-13T03:10:00.000Z","updated":"2020-03-02T06:46:52.166Z","comments":true,"path":"hexo-buildup/","link":"","permalink":"brynhild.online/hexo-buildup/","excerpt":"HEXO博客的基本搭建 安装 初始化 部署","text":"HEXO博客的基本搭建 安装 初始化 部署 事前准备 准备仓库 在GitHub上注册账号并创建仓库yourname.github.io 安装必要环境 安装node.js及git 完成后在命令窗口分别输入 123node -vnpm -vgit- version 如显示正确版本号即为成功. SSH授权 在目录下右键,git bash 1ssh-keygen -t rsa 在C盘用户目录下用记事本打开公钥,复制内容添加到GitHub. 在git bash中输入 1ssh -T git@github.com 测试是否成功. 安装及运行 安装和初始化HEXO 1234$ npm install hexo-cli -g$ hexo init$ hexo g$ hexo s HEXO命令一览 12345678910111213141516171819202122Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on console","categories":[{"name":"HEXO","slug":"HEXO","permalink":"brynhild.online/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"brynhild.online/tags/HEXO/"}]}]}