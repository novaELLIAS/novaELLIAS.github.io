{"meta":{"title":"Next Dream...","subtitle":null,"description":null,"author":"ELLIAS","url":"https://novaellias.github.io","root":"/"},"pages":[{"title":"","date":"2019-05-31T15:04:41.263Z","updated":"2019-05-31T15:04:41.263Z","comments":true,"path":"404.html","permalink":"https://novaellias.github.io/404.html","excerpt":"","text":"404 404 Not Found This object has escaped into fantacy. Please Contact the Administrator"},{"title":"","date":"2018-11-02T05:49:51.309Z","updated":"2018-11-02T05:49:51.278Z","comments":true,"path":"googleee23d67b90dfc2e5.html","permalink":"https://novaellias.github.io/googleee23d67b90dfc2e5.html","excerpt":"","text":"google-site-verification: googleee23d67b90dfc2e5.html"}],"posts":[{"title":"OPTIMIZATION","slug":"OPTIMIZE","date":"2018-11-07T11:17:42.000Z","updated":"2019-05-31T12:21:19.247Z","comments":true,"path":"2018/11/07/OPTIMIZE/","link":"","permalink":"https://novaellias.github.io/2018/11/07/OPTIMIZE/","excerpt":"编译选项 快读 快写 内嵌asm","text":"编译选项 快读 快写 内嵌asm LuoguBlog Fast Read &amp; WriteELLIAS_Old123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class fastio &#123; private: inline char gc() &#123; static char buf[1&lt;&lt;14],*p1=buf,*p2=buf; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;14,stdin),p1==p2)?EOF:*p1++; &#125; public: inline void getint (int &amp;to) &#123; register int x = 0; register char c = gc(); register bool m = 0; while (c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9') &amp;&amp; c != '-') c = gc(); if (c == '-') c = gc(), m = 1; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0', c = gc(); if (m) return -x; else return x; &#125; inline void getuint (int &amp;to) &#123; int x = 0; char c = gc(); while (!isdigit(c)) c = gc(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0', c = gc(); to = x; &#125; inline void getdou (double &amp;to) &#123; double x=0; char ch = getchar (); bool m = 0; while (!isdigit(ch) &amp;&amp; ch != '-') ch = gc (); if (ch == '-') ch = gc(), m = 1; while (isdigit(ch)) x = x * 10 + (ch-48), ch = gc (); if (ch == '.') &#123; double s = 0.1; ch = gc (); while (isdigit(ch)) x = x + (ch-48)*s,s/=10,ch = gc (); &#125; if (m) to = -x; else to = x; &#125; inline void getudou (double &amp;to) &#123; double x=0; char ch = gc (); while (!isdigit(ch)) ch = gc (); while (isdigit(ch)) x = x * 10 + (ch-48), ch = gc (); if (ch == '.') &#123; double s = 0.1; ch = gc (); while (isdigit(ch)) x = x + (ch-48)*s,s/=10,ch = gc (); &#125; to = x; &#125; inline void write (int x) &#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48); &#125;&#125; io; SJB1234567891011121314151617181920212223242526272829303132333435namespace fastIO &#123; const int str = 1&lt;&lt;20; const char* kiana = \"\\n\"; struct Reader &#123; char buf[str], *s, *t; bool EOF_FLG; Reader():s(buf), t(buf), EOF_FLG(false) &#123;&#125;; inline char gt() &#123;return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);&#125; template &lt;typename T&gt; Reader&amp;operator &gt;&gt; (T&amp;x) &#123; if (EOF_FLG)return *this; register char c=0,d; while (c != EOF &amp;&amp; (!isdigit(c)))d=c,c=gt(); if(c == EOF) &#123;EOF_FLG=true; return *this;&#125; else x = 0; while(isdigit(c)) x = (x&lt;&lt;3) + (x&lt;&lt;1) + c - '0', c = gt(); if (d == '-') x =- x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123;fwrite(buf,1,s-buf,stdout);&#125; inline void pt(char c) &#123;(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);&#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x) return pt('0'),*this; if(x&lt;0) pt('-'), x = -x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123;while(*s)pt(*s++);return *this;&#125; &#125; cout;&#125; ELLIAS_New1234567891011121314151617181920const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = 0; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') c = gc(), m = true; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (int x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125; SWITCHOLD (2017)123456789#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\") OLD(2018.3)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma GCC optimize (2)#pragma G++ optimize (2)#pragma GCC optimize (3)#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\")#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-fwhole-program\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-fstrict-overflow\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-skip-blocks\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"-funsafe-loop-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\") NOIp20181234567891011121314151617181920212223242526272829303132333435363738394041#pragma GCC optimize (2)#pragma GCC optimize (\"inline\")#pragma GCC optimize (\"-fgcse\")#pragma GCC optimize (\"-fgcse-lm\")#pragma GCC optimize (\"-fipa-sra\")#pragma GCC optimize (\"-ftree-pre\")#pragma GCC optimize (\"-ftree-vrp\")#pragma GCC optimize (\"-fpeephole2\")#pragma GCC optimize (\"-ffast-math\")#pragma GCC optimize (\"-fsched-spec\")#pragma GCC optimize (\"unroll-loops\")#pragma GCC optimize (\"-falign-jumps\")#pragma GCC optimize (\"-falign-loops\")#pragma GCC optimize (\"-falign-labels\")#pragma GCC optimize (\"-fdevirtualize\")#pragma GCC optimize (\"-fcaller-saves\")#pragma GCC optimize (\"-fcrossjumping\")#pragma GCC optimize (\"-fthread-jumps\")#pragma GCC optimize (\"-funroll-loops\")#pragma GCC optimize (\"-freorder-blocks\")#pragma GCC optimize (\"-fschedule-insns\")#pragma GCC optimize (\"inline-functions\")#pragma GCC optimize (\"-ftree-tail-merge\")#pragma GCC optimize (\"-fschedule-insns2\")#pragma GCC optimize (\"-fstrict-aliasing\")#pragma GCC optimize (\"-falign-functions\")#pragma GCC optimize (\"-fcse-follow-jumps\")#pragma GCC optimize (\"-fsched-interblock\")#pragma GCC optimize (\"-fpartial-inlining\")#pragma GCC optimize (\"no-stack-protector\")#pragma GCC optimize (\"-freorder-functions\")#pragma GCC optimize (\"-findirect-inlining\")#pragma GCC optimize (\"-fhoist-adjacent-loads\")#pragma GCC optimize (\"-frerun-cse-after-loop\")#pragma GCC optimize (\"inline-small-functions\")#pragma GCC optimize (\"-finline-small-functions\")#pragma GCC optimize (\"-ftree-switch-conversion\")#pragma GCC optimize (\"-foptimize-sibling-calls\")#pragma GCC optimize (\"-fexpensive-optimizations\")#pragma GCC optimize (\"inline-functions-called-once\")#pragma GCC optimize (\"-fdelete-null-pointer-checks\") 内嵌asm优化a * b % mo12345inline long long mul_mod (register long long a,register long long b,register long long mo) &#123; register long long ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\" : \"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo)); return ret;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://novaellias.github.io/tags/模板/"}]},{"title":"GSS1 - Can you answer these queries I","slug":"GSS1","date":"2018-11-02T02:08:23.000Z","updated":"2019-05-31T12:43:34.399Z","comments":true,"path":"2018/11/02/GSS1/","link":"","permalink":"https://novaellias.github.io/2018/11/02/GSS1/","excerpt":"GSS1 - Can you answer these queries I","text":"GSS1 - Can you answer these queries I Luogu SP1043Vjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define rint register intint n, m, x, y, in;struct node &#123; int sum, lmax, rmax, dat;&#125; tr[200001];namespace FastIO &#123; const int str=1&lt;&lt;20; const char* endl=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;(c&lt;'0'||c&gt;'9'))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;inline const int&amp; max(const int&amp; x,const int&amp; y) &#123; return x&gt;y?x:y;&#125;inline void update (int rt) &#123; tr[rt].sum =tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum; tr[rt].lmax= max (tr[rt&lt;&lt;1].lmax, tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].lmax); tr[rt].rmax= max (tr[rt&lt;&lt;1|1].rmax, tr[rt&lt;&lt;1|1].sum + tr[rt&lt;&lt;1].rmax); tr[rt].dat = max (max(tr[rt&lt;&lt;1].dat, tr[rt&lt;&lt;1|1].dat), tr[rt&lt;&lt;1].rmax + tr[rt&lt;&lt;1|1].lmax);&#125;inline void build (int rt,int l,int r) &#123; if(l==r) &#123; FastIO::cin&gt;&gt;in; tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = in; return; &#125; int mid = (l+r)&gt;&gt;1; build (lson); build (rson); update (rt);&#125;inline node query (int rt, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; int mid = (l+r)&gt;&gt;1; if (ql &gt; mid) return query (rson, ql, qr); if (qr &lt;= mid) return query (lson, ql, qr); else &#123; node ans,a,b; a = query (lson,ql,qr); b = query (rson,ql,qr); ans.sum = a.sum + b.sum; ans.dat = max (a.dat, a.rmax + b.lmax), ans.dat = max (ans.dat, b.dat); ans.lmax= max (a.lmax, a.sum + b.lmax); ans.rmax= max (b.rmax, b.sum + a.rmax); return ans; &#125;&#125;using namespace FastIO;int main() &#123; //freopen (\"nico.in\",\"r\",stdin); FastIO::cin&gt;&gt;n; build (1, 1, n); FastIO::cin&gt;&gt;m; while (m --) &#123; FastIO::cin&gt;&gt;x&gt;&gt;y; FastIO::cout&lt;&lt;query(1, 1, n, x, y).dat&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"SP1716 GSS3 - Can you answer these queries III","slug":"GSS3","date":"2018-11-02T02:08:23.000Z","updated":"2019-05-31T12:48:44.478Z","comments":true,"path":"2018/11/02/GSS3/","link":"","permalink":"https://novaellias.github.io/2018/11/02/GSS3/","excerpt":"GSS3 - Can you answer these queries III","text":"GSS3 - Can you answer these queries III LuoguVjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#pragma GCC optimize (\"-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2\", 3)#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define rint register intint n, m, x, y, in, opt;struct node &#123; int sum, lmax, rmax, dat, l, r;&#125; tr[200001];namespace FastIO &#123; const int str=1&lt;&lt;20; const char* endl=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;(c&lt;'0'||c&gt;'9'))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;inline const int&amp; max(const int&amp; x,const int&amp; y) &#123; return x&gt;y?x:y;&#125;inline void update (int rt) &#123; tr[rt].sum =tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum; tr[rt].lmax= max (tr[rt&lt;&lt;1].lmax, tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].lmax); tr[rt].rmax= max (tr[rt&lt;&lt;1|1].rmax, tr[rt&lt;&lt;1|1].sum + tr[rt&lt;&lt;1].rmax); tr[rt].dat = max (max(tr[rt&lt;&lt;1].dat, tr[rt&lt;&lt;1|1].dat), tr[rt&lt;&lt;1].rmax + tr[rt&lt;&lt;1|1].lmax);&#125;inline void build (int rt,int l,int r) &#123; tr[rt].l = l, tr[rt].r = r; if(l==r) &#123; FastIO::cin&gt;&gt;in; tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = in; return; &#125; int mid = (l+r)&gt;&gt;1; build (lson); build (rson); update (rt);&#125;inline node query (int rt, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; int mid = (l+r)&gt;&gt;1; if (ql &gt; mid) return query (rson, ql, qr); if (qr &lt;= mid) return query (lson, ql, qr); else &#123; node ans,a,b; a = query (lson,ql,qr); b = query (rson,ql,qr); ans.sum = a.sum + b.sum; ans.dat = max (a.dat, a.rmax + b.lmax), ans.dat = max (ans.dat, b.dat); ans.lmax= max (a.lmax, a.sum + b.lmax); ans.rmax= max (b.rmax, b.sum + a.rmax); return ans; &#125;&#125;inline void work (int rt, int to, int val)&#123; if (tr[rt].l == tr[rt].r) &#123; tr[rt].sum = tr[rt].lmax = tr[rt].rmax = tr[rt].dat = val; return; &#125; register int mid = (tr[rt].l + tr[rt].r) &gt;&gt; 1; if (to &lt;= mid) work (rt&lt;&lt;1, to, val); else work (rt&lt;&lt;1|1, to, val); update(rt);&#125;using namespace FastIO;int main ()&#123; //freopen (\"nico.in\",\"r\",stdin); cin &gt;&gt; n; build (1, 1, n); cin &gt;&gt; m; while (m --) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (opt) cout &lt;&lt; query (1, 1, n, x, y).dat &lt;&lt; endl; else work (1,x,y); &#125; return 0;&#125;","categories":[],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"Nescafé17 守卫者的挑战","slug":"Nescafe17-守卫者的挑战","date":"2018-11-02T02:08:23.000Z","updated":"2019-05-31T12:34:50.840Z","comments":true,"path":"2018/11/02/Nescafe17-守卫者的挑战/","link":"","permalink":"https://novaellias.github.io/2018/11/02/Nescafe17-守卫者的挑战/","excerpt":"Nescafé17 守卫者的挑战","text":"Nescafé17 守卫者的挑战 守卫者的挑战[Description]打开了黑魔法师Vani的大门,队员们在迷宫般的路上漫无目的地搜寻着关押applepi的监狱的所在地.突然,眼前一道亮光闪过.“我,Nizem,是黑魔法圣殿的守卫者.如果你能通过我的挑战,那么你可以带走黑魔法圣殿的地图……”瞬间,队员们被传送到了一个擂台上,最初身边有一个容量为K的包包. 擂台赛一共有项挑战,各项挑战依次进行.第项挑战有一个属性ai,如果ai≥0,表示这次挑战成功后可以再获得一个容量为ai的包包；如果ai = -1,则表示这次挑战成功后可以得到一个大小为 1 的地图残片.地图残片必须装在包包里才能带出擂台,包包没有必要全部装满,但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑,只需要完成所有N项挑战后背包容量足够容纳地图残片即可）,才能拼出完整的地图.并且他们至少要挑战成功L次才能离开擂台. 队员们一筹莫展之时,善良的守卫者Nizem帮忙预估出了每项挑战成功的概率,其中第i项挑战成功的概率为pi%.现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率. [Data Size]对于 100% 的数据,保证 $ 0≤K≤2000$ , $ 0≤N≤200$ , $-1≤ai≤1000$ , $0≤L≤N$ , $0≤pi≤100$ . [Solution]刚看到此题时,我被那个概率吓得半死.但看了数据范围,此题就是一道很简单的水题了. 对于可以赢l把以上并且背包不会溢出的概率 $P_0$ ,通过枚举结束时的背包容量和赢的次数快速求出: $$ P_0=\\sum_{i=l}^{n}\\sum_{j=0}^{K}P_{i, j} $$ 而 $P_{i, j}$ 可以通过刷表法 $O(n^2K)≈8*10^7$ 地求出: 定义状态 $dp[i][j][k]$ 代表达到第$i$场胜$j$场背包容量为$k$时的概率,转移方程很显然为本次成功的概率和本次失败的概率之和: 123dp[i][j][k] += dp[i-1][j][k] * (1 - dat[i].dat);if ((tmp = min (K + dat[i].opt, n)) &lt; 0) continue;dp[i][j+1][tmp] += dp[i-1][j][k] * dat[i].dat; 这个时间复杂度看起来很悬,未免会有稍作优化的想法.本题K的范围2000,但是真的需要2000吗?共有N项挑战,对于每一项挑战最多可以获得一块地图残片,所以背包实际的最大容量就是N次挑战中所有类型-1的数量,极限情况下是n,这样复杂度就会降到 $O(n^3)$, 较为稳妥. [Code]考场代码,写得略丑,请谅解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#pragma G++ optimize (3)#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;inline double getdou ()&#123; register double x=0; register char c = gc (); while (c &lt; '0' || c &gt; '9') c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = x * 10 + (c^'0'), c = gc(); if (c == '.') &#123; register double s = 0.1, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = x + (c-'0')*s, s/=10, c = gc (); &#125; return x;&#125;inline const int&amp; min (const int&amp; a, const int&amp; b)&#123;return a&lt;b? a:b;&#125;#define Re registerstruct node &#123; int opt; double dat;&#125; dat[201];inline bool cmp (node a, node b) &#123;return a.opt &gt; b.opt;&#125;double dp[201][201][201];signed main ()&#123; freopen (\"guard.in\", \"r\", stdin); freopen (\"guard.out\",\"w\",stdout); register int n = read (), l = read (), k = read (), tmp; for (Re int i = 1; i &lt;= n; ++ i) dat[i].dat = getdou()/100; for (Re int i = 1; i &lt;= n; ++ i) dat[i].opt = read (); std::sort (dat + 1, dat + n + 1, cmp); dp[0][0][min(n, k)] = 1.0; for (Re int i = 1; i &lt;= n; ++ i) &#123; for (Re int j = 0; j &lt;= i; ++ j) &#123; for (Re int K = 0; K &lt;= n; ++ K) &#123; dp[i][j][K] += dp[i-1][j][K] * (1 - dat[i].dat); if ((tmp = min (K + dat[i].opt, n)) &lt; 0) continue; dp[i][j+1][tmp] += dp[i-1][j][K] * dat[i].dat; &#125; &#125; &#125; register double ans = 0.0; for (Re int i = l; i &lt;= n; ++ i) for (Re int j = 0; j &lt;= n; ++ j) ans += dp[n][i][j]; printf (\"%.6lf\", ans); fclose (stdin), fclose (stdout); return 0;&#125; Cena评测$0.03s$,效率还是可以的.","categories":[],"tags":[{"name":"contest","slug":"contest","permalink":"https://novaellias.github.io/tags/contest/"},{"name":"DP","slug":"DP","permalink":"https://novaellias.github.io/tags/DP/"}]},{"title":"SP2916 GSS5 - Can you answer these queries V","slug":"GSS5","date":"2018-11-02T02:08:23.000Z","updated":"2019-05-31T12:52:39.423Z","comments":true,"path":"2018/11/02/GSS5/","link":"","permalink":"https://novaellias.github.io/2018/11/02/GSS5/","excerpt":"GSS4 - Can you answer these queries V","text":"GSS4 - Can you answer these queries V LuoguVjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#pragma GCC optimize (2)#pragma G++ optimize (2)#pragma GCC optimize (3)#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\")#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS], *p1 = buf, *p2 = buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = 0; while (c &lt; '0' || c &gt; '9') &#123;if (c == '-') m = true; c = gc();&#125; while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x)&#123; if (x &lt; 0ll) putchar('-'), x = -x; write (x), putchar ('\\n');&#125;#define Re register#define maxn 10001#define dmax 40001#define swap(x,y) ((y)^=(x)^=(y)^=(x)) struct node &#123; int l, r; long long sum, lmax, rmax, dat;&#125; tr[dmax], null;inline const long long&amp; max (const long long&amp; x,const long long&amp; y) &#123;return x&gt;y? x:y;&#125;inline void update (int rt)&#123; register int lson = rt&lt;&lt;1, rson = rt&lt;&lt;1|1; tr[rt].sum = tr[lson].sum + tr[rson].sum; tr[rt].lmax= max (tr[lson].lmax, tr[lson].sum + tr[rson].lmax); tr[rt].rmax= max (tr[rson].rmax, tr[rson].sum + tr[lson].rmax); tr[rt].dat = max (max(tr[lson].dat, tr[rson].dat), tr[lson].rmax + tr[rson].lmax);&#125;static void build (int rt, int l, int r) &#123; tr[rt].l = l, tr[rt].r = r; if (l == r) &#123;tr[rt].dat = tr[rt].sum = tr[rt].lmax = tr[rt].rmax = read (); return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid + 1, r); update (rt);&#125;static node query (int rt, int ql, int qr) &#123; register int l = tr[rt].l, r = tr[rt].r; if (ql &gt; qr) return null; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tr[rt]; register int mid = (l + r) &gt;&gt; 1; if (ql &gt; mid) return query (rt&lt;&lt;1|1,ql,qr); if (qr &lt;= mid) return query (rt&lt;&lt;1, ql, qr); else &#123; register node ret, a, b; a = query (rt&lt;&lt;1, ql, qr), b = query (rt&lt;&lt;1|1, ql, qr); ret.sum = a.sum + b.sum; ret.dat = max (a.dat, a.rmax + b.lmax), ret.dat = max (ret.dat, b.dat); ret.lmax= max (a.lmax, a.sum + b.lmax), ret.rmax= max (b.rmax, b.sum + a.rmax); return ret; &#125;&#125;static void modify (int rt, int to, long long val)&#123; if (tr[rt].l == tr[rt].r) &#123;tr[rt].sum = tr[rt].lmax = tr[rt].rmax = tr[rt].dat = val; return;&#125; register int mid = (tr[rt].l + tr[rt].r) &gt;&gt; 1; if (to &lt;= mid) modify (rt&lt;&lt;1, to, val); else modify (rt&lt;&lt;1|1, to, val); update(rt);&#125;int main() &#123; register int _ = read (); register int x1, y1, x2, y2; register int n, m; register node a, b, c; register long long tmp; register char opt; while (_ --) &#123; n = read ();//, m = read (); build (1, 1, n); m = read (); while (m --) &#123; //opt = 'z'; //while ((opt ^ 'C') &amp;&amp; (opt ^ 'Q')) opt = gc(); //if (opt ^ 'C') &#123; x1 = read (), y1 = read (), x2 = read (), y2 = read (); if (y1&lt;x1) swap(x1,y1); if (y2&lt;x2) swap(x2,y2); if (x1&gt;y2) swap(x1,x2), swap(y1,y2); if (y1 &lt; x2) &#123; writelen (max(query(1,x1,y1-1).rmax, 0) + query(1,y1,x2).sum + max(query(1,x2+1,y2).lmax, 0)); &#125; else &#123; a = query (1, x2, y1), b = query(1,x1,x2-1), c = query(1,y1+1,y2); tmp = a.dat; tmp = max (tmp, a.lmax + b.rmax); tmp = max (tmp, c.lmax + a.rmax); tmp = max (tmp, a.sum + max(0, b.rmax) + max(0, c.lmax)); writelen (tmp); &#125; &#125; //else &#123;x1 = read (), tmp = read (); modify (1, x1, tmp);&#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"SP2713 GSS4 - Can you answer these queries IV","slug":"GSS4","date":"2018-11-02T02:08:23.000Z","updated":"2019-05-31T12:49:50.872Z","comments":true,"path":"2018/11/02/GSS4/","link":"","permalink":"https://novaellias.github.io/2018/11/02/GSS4/","excerpt":"GSS4 - Can you answer these queries IV","text":"GSS4 - Can you answer these queries IV LuoguVjudge 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#pragma G++ optimize (\"Ofast\", 3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"sse3\",\"sse2\",\"sse\")#pragma GCC target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma GCC target (\"f16c\")#pragma G++ target (\"sse3\",\"sse2\",\"sse\")#pragma G++ target (\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")#pragma G++ target (\"f16c\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;math.h&gt;#define root 1,1,n#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define swap(x,y) y^=x^=y^=x#define maxn 100001 #define dmax 400001#define rint register int#define ll long longnamespace fastIO &#123; const int str=1&lt;&lt;20; const char* endll=\"\\n\"; struct Reader &#123; char buf[str],*s,*t; bool EOF_FLG; Reader():s(buf),t(buf),EOF_FLG(false) &#123;&#125;; inline char gt() &#123; return s==t&amp;&amp;((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++); &#125; #define gt() getchar() template&lt;typename T&gt;Reader&amp;operator&gt;&gt;(T&amp;x) &#123; if(EOF_FLG)return *this; register char c=0,d; while(c!=EOF&amp;&amp;!isdigit(c))d=c,c=gt(); if(c==EOF) &#123; EOF_FLG=true; return *this; &#125; else x=0; while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0',c=gt(); if(d=='-')x=-x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str],*s,*t; Writer():s(buf),t(buf+str) &#123;&#125; ~Writer() &#123; fwrite(buf,1,s-buf,stdout); &#125; inline void pt(char c) &#123; (s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c); &#125; #define pt(c) putchar(c) template&lt;typename T&gt;Writer&amp;operator&lt;&lt;(T x) &#123; if(!x)return pt('0'),*this; if(x&lt;0)pt('-'),x=-x; register char a[30],t=0; while(x)a[t++]=x%10,x/=10; while(t--)pt(a[t]+'0'); return *this; &#125; Writer&amp;operator&lt;&lt;(const char*s) &#123; while(*s)pt(*s++); return *this; &#125; &#125; cout;&#125;using namespace fastIO;struct TreeNode &#123; int l, r; long long sum, mxx;&#125; dat[dmax];long long in;inline const long long&amp; max (const long long&amp; x,const long long&amp; y) &#123;return x&gt;y? x:y;&#125;inline void update (int rt)&#123; dat[rt].sum = dat[rt&lt;&lt;1].sum + dat[rt&lt;&lt;1|1].sum; dat[rt].mxx = max (dat[rt&lt;&lt;1].mxx, dat[rt&lt;&lt;1|1].mxx);&#125;inline void build (int rt, int l, int r)&#123; dat[rt].l = l, dat[rt].r = r; if (l == r) &#123; fastIO::cin &gt;&gt; in; dat[rt].sum = dat[rt].mxx = in; return; &#125; register int mid = (l + r) &gt;&gt; 1; build (lson); build (rson); update (rt);&#125;inline long long query (int rt, int l, int r)&#123; register int L = dat[rt].l, R = dat[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return dat[rt].sum; register int mid = (L + R) &gt;&gt; 1; register long long ret = 0ll; if (l &lt;=mid) ret = query (rt&lt;&lt;1, l, r); if (mid &lt; r) ret += query (rt&lt;&lt;1|1,l,r); return ret;&#125;inline void change (int rt, int l, int r)&#123; register int L = dat[rt].l, R = dat[rt].r; if (L == R) &#123; //cout&lt;&lt;dat[rt].sum&lt;&lt;\" -&gt; \"; dat[rt].sum = sqrt (dat[rt].sum), dat[rt].mxx = sqrt (dat[rt].mxx); //cout&lt;&lt;dat[rt].sum&lt;&lt;endll; return; &#125; register int mid = (L + R) &gt;&gt; 1; if (l&lt;=mid &amp;&amp; dat[rt&lt;&lt;1].mxx &gt;1) change (rt&lt;&lt;1, l, r); if (mid&lt; r &amp;&amp; dat[rt&lt;&lt;1|1].mxx&gt;1) change (rt&lt;&lt;1|1,l,r); update (rt);&#125;//using namespace fastIO;inline void Write (const int&amp; x, const int&amp; y) &#123;cout &lt;&lt; query(1, x, y) &lt;&lt; endll;&#125;inline void Change (const int&amp; x, const int&amp; y) &#123;change (1, x, y);&#125;int main ()&#123; register int _ = 0, n; while (scanf (\"%d\", &amp;n) != EOF) &#123; fastIO::cout &lt;&lt; \"Case #\" &lt;&lt; ++ _ &lt;&lt; \":\" &lt;&lt; endll; build (root); register int m, x, y, ret; register bool opt; fastIO::cin &gt;&gt; m; while (m --) &#123; fastIO::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (x &gt; y) swap (x, y); opt? Write(x, y):Change (x, y); &#125; putchar ('\\n'); &#125; return 0;&#125;","categories":[],"tags":[{"name":"GSS","slug":"GSS","permalink":"https://novaellias.github.io/tags/GSS/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"}]},{"title":"洛谷 线段树模板","slug":"洛谷-线段树模板","date":"2018-06-08T11:29:26.000Z","updated":"2019-05-31T12:34:48.916Z","comments":true,"path":"2018/06/08/洛谷-线段树模板/","link":"","permalink":"https://novaellias.github.io/2018/06/08/洛谷-线段树模板/","excerpt":"洛谷 线段树1 线段树2 模板","text":"洛谷 线段树1 线段树2 模板 P3372 [模板] 线段树 1Luogu P3372 线段树加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma GCC optimize (2)//...略#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;#define Re register#define maxn 100001#define dmax 400001typedef long long ll;#define swap(x,y) ((x)^=(y)^=(x)^=(y))struct SMT &#123; int l, r; long long sum, tag;&#125; tr[dmax];inline void update (Re int rt) &#123; tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;&#125;static void build (Re int rt, Re int l, Re int r)&#123; tr[rt].l = l, tr[rt].r = r; if (l == r) &#123;tr[rt].sum = read(); return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid+1, r); update (rt);&#125;inline void pushdown (Re int rt)&#123; if (rt &gt; 200000 || !tr[rt].tag) return; register int ls = rt&lt;&lt;1, rs = rt&lt;&lt;1|1; tr[ls].tag += tr[rt].tag, tr[rs].tag += tr[rt].tag; tr[ls].sum += tr[rt].tag * (tr[ls].r - tr[ls].l + 1), tr[rs].sum += tr[rt].tag * (tr[rs].r - tr[rs].l + 1); tr[rt].tag = 0;&#125;static void modify (Re int rt, Re int l, Re int r, Re ll val)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; tr[rt].sum += val * (R - L + 1), tr[rt].tag += val; return; &#125; register int mid = (L + R) &gt;&gt; 1; pushdown (rt); if (l &lt;= mid) modify (rt&lt;&lt;1, l, r, val); if (r &gt; mid) modify (rt&lt;&lt;1|1,l,r, val); update (rt);&#125;static long long query (Re int rt, Re int l, Re int r)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].sum; pushdown (rt); register int mid = (L+R)&gt;&gt;1; register long long ret = 0; if (l &lt;= mid) ret = query (rt&lt;&lt;1, l, r); if (r &gt; mid) ret += query (rt&lt;&lt;1|1,l,r); return ret;&#125;signed main ()&#123; register int n=read(), m=read(); register int opt, x, y; register long long z; build (1, 1, n); while (m --) &#123; opt=read(), x=read(), y=read(); if (x &gt; y) swap (x, y); if (opt == 2) writelen (query (1, x, y)); else z = read (), modify (1, x, y, z); &#125; return 0;&#125; P3373 [模板]线段树 2Luogu P3372 加 乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#pragma GCC optimize (2)//..略#pragma GCC target (\"f16c\")#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void writelen (long long x) &#123;if(x&lt;0)x=-x,putchar('-'); write (x); putchar ('\\n');&#125;inline long long mul_mod (register long long a,register long long b,register long long mo) &#123; register long long ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\" : \"=d\"(ret):\"a\"(a),\"b\"(b),\"c\"(mo)); return ret;&#125;#define Re register#define maxn 100001#define dmax 400001typedef long long ll;#define swap(x,y) ((x)^=(y)^=(x)^=(y))#define mod(x) (((x)%modn+modn)%modn)long long modn;struct SMT &#123; int l, r; long long sum, add, mul;&#125; tr[dmax];inline void update (Re int rt) &#123; tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;&#125;static void build (Re int rt, Re int l, Re int r)&#123; tr[rt] = &#123;l, r, 0ll, 0ll, 1ll&#125;; if (l == r) &#123;tr[rt].sum = read()%modn; return;&#125; register int mid = (l + r) &gt;&gt; 1; build (rt&lt;&lt;1, l, mid), build (rt&lt;&lt;1|1, mid+1, r); update (rt);&#125;inline void pushdown (Re int rt)&#123; if (rt &gt; 200000 || (!tr[rt].add &amp;&amp; tr[rt].mul == 1ll)) return; register int ls = rt &lt;&lt; 1, rs = rt &lt;&lt; 1 | 1; tr[ls].mul = mul_mod (tr[ls].mul, tr[rt].mul, modn); tr[rs].mul = mul_mod (tr[rs].mul, tr[rt].mul, modn); tr[ls].add = mod (mul_mod (tr[ls].add , tr[rt].mul, modn) + tr[rt].add); tr[rs].add = mod (mul_mod (tr[rs].add, tr[rt].mul, modn) + tr[rt].add); tr[ls].sum = mod (mul_mod (tr[ls].sum, tr[rt].mul, modn) + mul_mod (tr[rt].add, (tr[ls].r - tr[ls].l + 1), modn)); tr[rs].sum = mod (mul_mod (tr[rs].sum, tr[rt].mul, modn) + mul_mod (tr[rt].add, (tr[rs].r - tr[rs].l + 1), modn)); tr[rt].add = 0ll, tr[rt].mul = 1ll;&#125;// opt==1: mul opt==2: addstatic void modify (Re int rt, Re int l, Re int r, Re ll val, Re int opt)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; if (opt == 2) &#123; tr[rt].add = mod (tr[rt].add + val),\\ tr[rt].sum = mod (tr[rt].sum + mul_mod (val, (R - L + 1), modn)); return; &#125; else &#123; tr[rt].mul = mul_mod (tr[rt].mul, val, modn),\\ tr[rt].sum = mul_mod (tr[rt].sum, val, modn),\\ tr[rt].add = mul_mod (tr[rt].add, val, modn); return; &#125; &#125; pushdown (rt); register int mid = (L + R) &gt;&gt; 1; if (l &lt;= mid) modify (rt&lt;&lt;1, l, r, val, opt); if (r &gt; mid) modify (rt&lt;&lt;1|1,l,r, val, opt); update (rt);&#125;static long long query (Re int rt, Re int l, Re int r)&#123; register int L = tr[rt].l, R = tr[rt].r; if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].sum; pushdown (rt); register int mid = (L+R)&gt;&gt;1; register long long ret = 0; if (l &lt;= mid) ret = query (rt&lt;&lt;1, l, r); if (r &gt; mid) ret += query (rt&lt;&lt;1|1,l,r); return ret % modn;&#125;signed main ()&#123; register int n=read(), m=read(); modn=read(); register int opt, x, y; register long long z; build (1, 1, n); while (m --) &#123; opt=read(), x=read(), y=read(); if (x &gt; y) swap (x, y); if (opt == 3) writelen (query (1,x,y)); else z=read()%modn,modify(1,x,y,z,opt); &#125; return 0;&#125;","categories":[],"tags":[{"name":"segment tree","slug":"segment-tree","permalink":"https://novaellias.github.io/tags/segment-tree/"},{"name":"模板","slug":"模板","permalink":"https://novaellias.github.io/tags/模板/"}]},{"title":"最短路模板","slug":"最短路模板","date":"2017-12-05T06:47:00.000Z","updated":"2019-05-31T12:34:45.390Z","comments":true,"path":"2017/12/05/最短路模板/","link":"","permalink":"https://novaellias.github.io/2017/12/05/最短路模板/","excerpt":"SPFA 堆优化迪杰斯特拉C++模板","text":"SPFA 堆优化迪杰斯特拉C++模板 SPFALuogu P3371 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma G++ optimize (3)#include &lt;cstdio&gt;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline long long read ()&#123; register long long x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; c ^ '-') c = gc(); if (c == '-') m = true, c = gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (long long x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;inline const int&amp; min (const int&amp; a, const int&amp; b) &#123;return a&lt;b? a:b;&#125;#define Re register#define maxn 10001#define maxm 500001int head[maxn], nxt[maxm], too[maxm], ecnt;long long wei[maxm], dis[maxn];int que[maxm*100 + 100];bool vis[maxn];signed main ()&#123; register int n = read (), m = read (), sta = read (); for (Re int i = 1; i &lt;= n; ++ i) dis[i] = 2147483647; register int fr, to, va; while (m --) &#123; fr = read (), to = read (), va = read (); nxt[++ ecnt] = head[fr], head[fr] = ecnt, too[ecnt] = to, wei[ecnt] = va; &#125; dis[sta] = 0; register int hd = 0, tl = 1; que[tl] = sta; while (hd &lt; tl) &#123; fr = que[++ hd], vis[fr] = false; for (Re int i = head[fr]; i; i = nxt[i]) &#123; to = too[i], va = wei[i]; if (dis[to] &gt; dis[fr] + va) &#123; dis[to] = dis[fr] + va; if (!vis[to]) vis[to] = true, que[++ tl] = to; &#125; &#125; &#125; for (Re int i = 1; i &lt;= n; ++ i) &#123; if (dis[i]&lt;0) dis[i] = -dis[i], putchar ('-'); write (dis[i]), putchar (' '); &#125; return 0;&#125; 堆优化迪杰斯特拉Luogu P4779 OLD (2017)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#pragma G++ optimize (3)#pragma GCC optimize (\"Ofast\", 3)#pragma GCC target (\"avx\",\"sse2\")#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;#define maxn 100001#define maxm 200001#define inff 2147483647inline int read () &#123; int x = 0; char c = getchar(); bool m = false; while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') c = getchar(), m = true; while (isdigit(c)) x = x * 10 + c - 48, c = getchar(); if (m) return -x; else return x;&#125;inline void fastwrite (int x) &#123; if(x &lt; 0) x = -x, putchar('-'); if(x &gt; 9) fastwrite(x / 10); putchar(x%10 + '0');&#125;inline void fastwritespace (int x) &#123; fastwrite(x); putchar(' ');&#125;struct node &#123; int val, name;&#125;;struct cmp &#123; inline bool operator() (const node&amp; aa, const node&amp; bb) &#123; return aa.val &gt; bb.val; &#125;&#125;;int n, m, s, fro, to, w;int dis[maxn];bool visit[maxn];vector &lt;pair &lt;int, int&gt; &gt; data[maxn];__gnu_pbds::priority_queue &lt;node, cmp, pairing_heap_tag&gt; nico;int main () &#123; n = read (), m = read (), s = read (); for (int i = 1; i &lt;= m; i ++) &#123; fro = read (), to = read (), w = read (); data[fro].push_back (make_pair (to, w)); &#125; for (int i = 1; i &lt;= n; i ++) dis[i] = inff; dis[s] = 0; nico.push ((node) &#123; 0, s &#125;); while (!nico.empty ()) &#123; fro = nico.top ().name; nico.pop (); if (visit[fro]) continue; visit[fro] = true; for (int i = 0; i &lt; data[fro].size (); i ++) &#123; to = data[fro][i].first; w = data[fro][i].second; if (!visit[to] &amp;&amp; dis[fro] + w &lt; dis[to]) &#123; dis[to] = dis[fro] + w; nico.push ((node) &#123; dis[to], to &#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i ++) fastwritespace (dis[i]); return 0;&#125; NEW(2018/11/5)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#pragma G++ optimize (3)#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using std::priority_queue;const int ELAS = 1&lt;&lt;14;static char buf[ELAS],*p1=buf,*p2=buf;inline char gc()&#123; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,ELAS,stdin),p1==p2)?EOF:*p1++;&#125;inline int read ()&#123; register int x = 0; register char c = gc(); register bool m = false; while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c ^ '-')) c = gc(); if (c == '-') m = true, c = gc (); while (c&gt;='0'&amp;&amp;c&lt;='9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^'0'), c = gc(); return m? -x:x;&#125;static void write (int x)&#123; if (x &gt; 9) write (x / 10); putchar (x % 10 + 48);&#125;static void nwrite (int x) &#123;write (x); putchar (' ');&#125;#define maxn 100001#define maxm 200001#define Re registerstruct node &#123; int id, val; friend bool operator &lt; (node a, node b) &#123; return a.val &gt; b.val; &#125;&#125;;priority_queue &lt;node&gt; que;int head[maxn], wei[maxm], too[maxm], nxt[maxm], ecnt;bool vis[maxn];int dis[maxn];signed main ()&#123; register int n = read (), m = read (), sta = read (); register int fr, to, va; while (m --) &#123; fr = read (), nxt[++ ecnt] = head[fr],\\ head[fr] = ecnt, too[ecnt] = read (), wei[ecnt] = read (); &#125; memset (dis, 0x3f3f3f3f, sizeof dis); dis[sta] = 0; que.push (&#123;sta, 0&#125;); while (!que.empty ()) &#123; fr = que.top ().id, que.pop (); if (!vis[fr]) &#123; vis[fr] = true; for (Re int i = head[fr]; i; i = nxt[i]) &#123; to = too[i], va = wei[i]; if (dis[fr] + va &lt; dis[to]) &#123; dis[to] = dis[fr] + va; que.push (&#123;to, dis[to]&#125;); &#125; &#125; &#125; &#125; for (Re int i = 1; i &lt;= n; ++ i) nwrite (dis[i]); return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://novaellias.github.io/tags/模板/"},{"name":"最短路","slug":"最短路","permalink":"https://novaellias.github.io/tags/最短路/"}]}]}